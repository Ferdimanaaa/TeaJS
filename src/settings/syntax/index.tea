
#expr SyntaxPatt <\<...\>>
{
	#script
		text = node.text;
		text = text.replace(/^\s*<|>\s*$/g, '').trim();
		text = text.replace(/\n\s*/g,  ' ');
		text = text.replace(/ {2,}/g,  ' ');
		text = '"'+SText(text, '"')+'"';
		return new Card('STRING', text);
	#end
}

module.exports = {

	"COMMENT"             : require("./comment.js")

	"Root"                : require("./root.js")

	"Block"               : require("./block.js")

	"StamBlock"           : <Block | Statement@:BlockStam>

	"Statement"           : <LabelStam |
							(	\{ → [JsonAssignExpr JsonExpr Block] |
								\[ → ArrayAssignExpr                 |
								#SUGAR(stam)                    |
								[Declaration Keyword MethodDecl LinkStam Comma]
							)\n (CLOSE → | #CHECK(last, ==, Expression) [SeleteLeft SeleteRight]@@SeleteStam | SeleteLeft@@SeleteStam | END∅∆1101)>

	"Expression"           : <[class → Class, Ternary] (#CHECK(last, ==, Access) (Params@@CallExpr | (=@@AssignExpr | ASSIGN@@AssignPatt) Expression∆1107))?>

	"Object"              : <CONST | ArrowExpr | [\@ → AtExpr, \[ → ArrayExpr,\( → CompelExpr,\{ → JsonExpr, super → SuperExpr, require → RequireExpr, function → FunctionExpr, VariableExpr, #SUGAR(expr)]>
	"Access"              : <Object (MemberExpr@~AccessExpr)*>
	"Value"               : <[@ this]?@@ThisExpr → Object (MemberExpr@~AccessExpr | ParamsExpr@~CallExpr)* SlicePatt?@~SliceExpr>

	"CONST"               : <REGEXP | STRING | TAG>
	"REGEXP"              : <[\/ \/=] → #CONCAT( \/=\\|\/...*\/\\|\/ [g i m y]*, , REGEXP CONST)>
	"STRING"              : <QUOTE → #CONCAT( , , STRING CONST)>
	"TAG"                 : <# → #CONCAT(#+ [IDENTIFIER KEYWORD], , TAG CONST)>

	
	"MemberExpr"    	  : <[ . → . [IDENTIFIER KEYWORD]∆1108, \[ → \\[ CommaExpr \\], :: → :: [IDENTIFIER KEYWORD]?]>
	"AtExpr"              : <@ [IDENTIFIER KEYWORD]?>
	"SuperExpr"           : <super (MemberExpr*)@:SuperMember Params?>
	"SlicePatt"           : <\[∅ \]∅ | \[∅ (Compute? : Compute?) \]∆1109∅>

	"JsonExpr"            : <\{∅ ( \}∅ | JsonItem (,?∅ JsonItem)* ,*∅ \}∆1123∅)>
	"JsonItem"            : <set→ SetterDecl | get→ GetterDecl | IDENTIFIER→ #IS(+1, \() → MethodDecl | ([NameExpr NUMBER STRING] : Expression)@:AssignExpr>

	"ArrayExpr"           : <\[∅ \]∅ | \[∅ Expression (,?∅ Expression)* ,*∅ \]∆1124∅>
	"VariableExpr"        : <IDENTIFIER>
	"NameExpr"            : <IDENTIFIER | KEYWORD #ARGU(id)!∆1006>

	"Declaration"         : <[
							var          → VarStam,
							let          → LetStam,
							const        → ConstStam,
							function     → FunctionDecl,
							class        → Class,
							import       → ImportStam,
							export       → ExportDecl,
							static       → StaticDecl,
							get          → GetterDecl,
							set          → SetterDecl,
							prototype    → ProtoDecl,
							property     → PropertyDecl,
							constructor  → ConstructorDecl]>

	"Keyword"             : <[
							return       → ReturnStam,
							break        → BreakStam,
							continue     → ContinueStam,
							throw        → ThrowStam,
							debugger     → DebuggerStam,
							if           → IfStam,
							while        → WhileStam,
							do           → DoWhileStam,
							with         → WithStam,
							try          → TryStam,
							switch       → SwitchStam,
							for          → ForStam,
							yield        → YieldStam]>

	// TODO: coming soon for support syntax  
	"YieldStam"           : <yield Expression>
	"ImportStam"          : <import!∆1>
	"ExportDecl"          : <export∅ (default [MethodDecl Declaration Expression] | [MethodDecl Declaration ArgusStam])∆1011>
	// -----------------------------

	"Unary"               : <not Expression@@NotExpr | PREFIX Value@@PrefixExpr | new Value@@NewExpr | UNARY #Unary@@UnaryExpr | Value POSTFIX?@@PostfixExpr>

	"ComputeLv0"          : <Unary (PREC0 Unary@~ComputeExpr)*>             // *  /  %  **  \\\\
	"ComputeLv1"          : <ComputeLv0 (PREC1 ComputeLv0@~ComputeExpr)*>   // +  -
	"ComputeLv2"          : <ComputeLv1 (PREC2 ComputeLv1@~ComputeExpr)*>   // >>  <<  >>>
	"CompareLv3"          : <ComputeLv2 (PREC3 ComputeLv2@~CompareExpr)*>   // >  <  >=  <=  instanceof  in  of  as  @
	"Compare"             : <CompareLv3 (PREC4 CompareLv3@~CompareExpr)*>   // !=  !==  ==  ===  is  not is
	"Compute"             : <Compare (PREC5 Compare@~ComputeExpr)*>         // ^  ~  &  |
	"Operate"             : <Compute (PREC6 [return → ReturnStam, break → BreakStam, continue → ContinueStam, throw → ThrowStam, debugger → DebuggerStam, Assign, Compute]@~LogicExpr)*> // and  or  &&  ||
	"Binary"              : <Assign | Operate>
	"Ternary"             : <Operate (\?@@TernaryExpr [Declaration Keyword Expression] (: [Declaration Keyword Expression])?)?>
	
	"Rest"                : <...?∅@@RestExpr IDENTIFIER>
	"ArrayAssignExpr"     : <[∅ (Rest (,∅ Rest)*)@:ArrayPatt ]∅ = Expression>
	"JsonAssignExpr"      : <{∅ ((IDENTIFIER (\: IDENTIFIER)?)@?AssignExpr (,∅ (IDENTIFIER (\: IDENTIFIER)?)@?AssignExpr)*)@:JsonPatt }∅ = Expression>
	"Assign"              : <[\[ → ArrayAssignExpr, \{ → JsonAssignExpr, Access (=@@AssignExpr | ASSIGN@@AssignPatt) Expression∆1107 ]>

	"ArgusItem"           : <[ ... → Rest, \[  → ArrayAssignExpr, \{  → JsonAssignExpr, VariableExpr (= Expression)?@@AssignExpr ]>
	"Argus"               : <ArgusItem (,∅ ArgusItem)*>
	"ArgusStam"           : <ArgusItem (,∅ ArgusItem)*>
	"ArgusExpr"           : <\(∅ (\)∅ | ArgusItem (,∅ ArgusItem)* \)∅)>
	
	"ParamsGroup"         : <(Expression (, [\, \)]→)*) (,∅ Expression (, [\, \)]→)*)*>
	"ParamsExpr"          : <\(∅ ( \)∅ | ,* ParamsGroup \)∆1104∅)>
	"Params"              : <ParamsExpr | #IS(--1, BLANK) → #NOT(--2, END) → ParamsGroup@:ParamsExpr>

	"CommaExpr"           : <Expression (,∅ Expression∆1125)*>
	"Comma"               : <Expression (,∅ Expression∆1125)*@@CommaExpr>
	"CompelExpr"          : <(∅ CommaExpr∆1126 )∅>
	"LabelStam"           : <IDENTIFIER : Statement>
	"SeleteLeft"          : <(<- | if\n) Comma∆1127>
	"SeleteRight"         : <[&& || and or ->] Statement∆1127>
	"LinkStam"            : <Access (..∅ (Access Params?)@:LinkPatt)+>

	// 
	
	
	"VarStam"             : <var∅      ArgusStam∆1007>
	"LetStam"             : <let∅      ArgusStam∆1009>
	"ConstStam"           : <const∅    ArgusStam∆1010>

	"ReturnStam"          : <return\n   CommaExpr?>
	"BreakStam"           : <break\n    IDENTIFIER?>
	"ContinueStam"        : <continue\n IDENTIFIER?>
	"ThrowStam"           : <throw\n    CommaExpr?>
	"RequireExpr"         : <require    Params>
	"DebuggerStam"        : <debugger>
	
	"FunctionExpr"        : <function \*?@@GeneratorExpr  #NameExpr(id)?@@FunctionDecl ArgusExpr Block>
	"FunctionDecl"        : <function \*?@@GeneratorDecl  #NameExpr(id)∆1024 ArgusExpr Block>
	"MethodDecl"          : <NameExpr     ArgusExpr [\{ :] → Block∆1106>
	"ArrowExpr"           : <(ArgusExpr | IDENTIFIER@:ArgusExpr) =>∅ (\{→ [JsonExpr Block] | ReturnStam | ThrowStam | Expression)>

	"Class"               : <class@@ClassExpr (extends! → #NameExpr(id)?@@ClassDecl) (extends Params∆1021)?@:ExtendsExpr Block>
	"GetterDecl"          : <get∅        NameExpr ArgusExpr?@!ArgusExpr Block>
	"SetterDecl"          : <set∅        NameExpr ArgusExpr Block>
	"StaticDecl"          : <static∅     [MethodDecl ArgusStam]>
	"ProtoDecl"           : <prototype∅  [MethodDecl ArgusStam]>
	"PropertyDecl"        : <property∅   [MethodDecl ArgusStam]>
	"ConstructorDecl"     : <constructor@:NameExpr  ArgusExpr [\{ :] → Block∆1106>
	
	"If"                  : <if ConditionExpr StamBlock∆1012@@IfPatt>
	"Else"                : <else@@ElsePatt (if∅ ConditionExpr@@ElseIfPatt | ConditionExpr [\{ :]→@@ElseIfPatt)? StamBlock∆1019>
	"Try"                 : <try     StamBlock∆1016@@TryPatt>
	"Catch"           	  : <catch   ConditionExpr StamBlock@@CatchPatt>
	"Finally"             : <finally StamBlock@@FinallyPatt>
	"WhileStam"           : <while   ConditionExpr StamBlock∆1013>
	"WithStam"            : <with    ConditionExpr StamBlock∆1014>
	"SwitchStam"          : <switch  ConditionExpr (\:∅ #Case(indent)* | \{∅ #Case* \}∆1110∅)@:BlockNode∆1017>
	"Case"                : <(case@@CaseStam CommaExpr | default@@DefaultStam) \:∆1020∅ (#ARGU(indent) #Block(indent, case, default) | #ARGU(indent)! #Block(brace, case, default))?>
	
	"ConditionExpr"       : <Comma #CHECK(last, ==, CompelExpr)?@@=ConditionExpr>

	"ForStam"             : <for ForCondition∆1022 StamBlock∆1106>
	"ForCondition"        : require('./for.js')
	"IfStam"              : <If  (#INDENT Else)*>
	"TryStam"             : <Try (#INDENT Catch)? (#INDENT Finally)?>
	"DoWhileStam"         : <do  StamBlock∆1015 (#INDENT while ConditionExpr)?>
}