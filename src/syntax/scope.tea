
class Scope:
	
	var global_scope = new Scope();
		global_scope.type = 'Global';
		global_scope.top = null;

	constructor(node):
		// @.id        = ID();
		@.name      = null;
		if node && (node.isnode || node.istoken):
			@.node         = node;
			@.type         = node.type;
			@.node.scope   = @;
			// @.node.scopeID = @.id;
		else:
			@.type      = node || '?';
		
		@.variables = {};
		@.lets      = {};
		@.consts    = [];
		@.exports   = [];
		@.argumentsDefine = [];
		@.sub       = [];

		switch @.type:
			case 'ClassExpr':
				@.construct = null;
				@.inits     = [];
				@.protos    = [];
				@.statics   = [];

			case 'Root':
				@.requires = {length:0};
			
	get top:
		if !@._top_:
			var scopeParent = @.node && @.node.scopeParent;
			@._top_ = scopeParent && scopeParent.scope || global_scope;
		return @._top_;

	set top(scope):
		scope.addSub(@);
		return @._top_ = scope;

	get parent:
		var top = @.top;
		while top.isLetScope:
			top = top.top;
		return top;

	get root:
		var rot = @;
		while rot && rot.type != 'Root':
			rot = rot.top;
		return rot || global_scope;

	queryParent(type):
		var p = @;
		while p && p.type != type:
			if p.type == 'Root' || p.type == 'Global':
				return;
			p = p.top;
		return p;

	addSub(scope):
		if @.sub.indexOf(scope) == -1:
			@.sub.push(scope);
		return @;

	set (type, name, force):
		var names = name as 'string' ? [name] : name;
		for i, name -> names:
			if type in @ && isArray(@[type]):
				if @[type].indexOf(name) == -1:
					 @[type].push(name);
				return @;

			var variables = @.variables;
			if force || not name in variables:
				variables[name] = type;
		return @;

	get (type):
		var variables = @.variables;
		var list = [];
		for name in variables:
			if variables[name] == type:
				list.push(name);
		return list;

	setLet(name, rename):
		@.set('let', name);
		if rename:
			@.lets[name] = rename;

	getLet(name):
		var scope = @.isDefined(name, 'let', 100, true);
		if scope:
			return scope.lets[name] || name;

	isDefined(name, type, level, ret_scope):
		var scope = @, _scope;
		level |= 100;
		while scope && scope != _scope && level--:
			_scope = scope;
			variables = scope.variables;
			if name in variables:
				type = type ? variables[name] == type : variables[name];
				if ret_scope && type:
					return scope;
				return type;
			if type == 'let' && !scope.isLetScope:
				break;
			scope = scope.top;
		return false;

	create(node, let_type):
		var scope = new Scope(node);
			scope.top = @;
		if let_type:
			scope.isLetScope = true;
		return scope;

	addRequire(file):
		if !Path.isFile(file):
			Err 'join the "'+file+'" file not exist';
		if file in @.requires:
			return @.requires[file];
		var key = Path.join( './', Path.relative(tea.argv.outdir||'', file ) );
		@.requires[file] = key;
		@.requires.length ++;
		return key;

	static parse(node, __scope, __let_scope):
		__scope |= node.scope || global_scope;
		switch node.is('ScopeNode', 'ControlStam'):
			case 'ScopeNode':
				__scope = __scope.create(node);
				__let_scope = null;
			case 'ControlStam':
				__let_scope = (__let_scope||__scope).create(node, 'let');
			default:
				node.scope = __let_scope || __scope;

		for i, item -> node:
			item.scope = __let_scope || __scope;
			if item.type == 'IdentifierTokn':
				checkIdentifier(node, item, __scope, __let_scope);
			if item.isnode:
				Scope.parse(item, __scope, __let_scope);
		return __scope;

	function createScope(node, parent_scope):
		var scope = new Scope(node);
			scope.top = parent_scope;
		return scope;
	
	function checkIdentifier(parent, id, scope, let_scope):
		var idexpr, ass_expr, argu_expr, arr_patt, expr;
		var p = parent;
		do:
			if p.type == 'IdentifierExpr':
				idexpr = p;
				continue;
			if p.type == 'ArrayPatt':
				arr_patt = p;
				continue;
			if p.type == 'AssignmentDecl' || p.type == 'AssignmentExpr':
				ass_expr = p;
				continue;
			if p.type == 'ArgumentsDecl' || p.type == 'ArgumentsExpr':
				argu_expr = p;
				continue;
			if  p.type == 'CommaExpr' ||  p.type == 'CommaStam' || p.type == 'NodeStam':
				continue;
			expr = p;
			break;
		while p = p.parent;

		if !idexpr:
			if argu_expr:
				if let_scope && let_scope.type == 'ForStam' && expr.type == 'VarDecl' && /ForPConditionPatt|ForInConditionPatt/.test(expr.parent.type):
					checkArguments('LetDecl', ass_expr, id, scope, let_scope);
				else:
					checkArguments(expr.type, ass_expr, id, scope, let_scope);
			else if expr.is('FunctionDecl', 'GetterDecl', 'SetterDecl', 'MethodDecl', 'ClassExpr', 'ClassExpr'):
				checkFunctionName(parent, id, scope);
			else if ass_expr && arr_patt:
				checkIdentifierExpr(expr, ass_expr, arr_patt, id, scope, let_scope);

			else if /AtExpr/.test(parent.parent.type) && parent.index == 1:
				checkAt(parent.parent, id);
			
		else:
			checkIdentifierExpr(expr, ass_expr, idexpr, id, scope, let_scope)
		return;

	function checkAt(parent, id):
		if parent.length == 2 && parent.parent.type == 'AssignmentExpr':
			scope =  parent.offsetScope;
			if scope.type == 'ClassExpr':
				scope.set( 'statics', id.text );
				scope.set( 'static', id.text );
				return;
			top_scope = scope.parent;
			if top_scope.type == 'ClassExpr':
				if top_scope.protos.indexOf(scope.name) != -1:
					top_scope.set('protos', id.text);
					top_scope.set('proto', id.text, true);
				else if top_scope.statics.indexOf(scope.name) != -1:
					top_scope.set( 'statics', id.text );
					top_scope.set( 'static', id.text );
				

	function checkArguments(expr_type, ass_expr, id, scope, let_scope):
		switch expr_type:
			case 'LetDecl':
				if let_scope:
					let_scope.set('let', id.text);
				else:
					scope.set('let', id.text);
			case 'ConstDecl':
				if root = scope.root:
					root.set('undefined', id.text);
					root.set('consts', id.text);
				scope.set('const', id.text);

			case 'VarDecl':
				scope.set('defined', id.text);

			case 'ExportDecl':
				if !scope.isDefined( id.text )
					scope.set('undefined', id.text);
				scope.set('exports', id.text);

			case 'ProtoDecl', 'InitDecl':
				scope.set('protos', id.text);
				scope.set('proto', id.text, true);

			case 'StaticDecl':
				scope.set('statics', id.text);
				scope.set('static', id.text);

			case 'FunctionExpr', 'FunctionDecl', 'GetterDecl', 'SetterDecl', 'MethodDecl', 'LambdaExpr':
				scope.set('argument', id.text);
				if ass_expr:
					scope.argumentsDefine.push( ass_expr.clone() );

	function checkFunctionName(parent, id, scope):
		var expr_type = parent.parent.type;
		if expr_type == 'JsonExpr':
			return;
		var top_scope = scope.parent;
		if expr_type == 'ExportDecl':
			top_scope.set('exports', id.text);
		switch parent.type:
			case 'GetterDecl':
				top_scope.set('getter', id.text);
			case 'SetterDecl':
				top_scope.set('setter', id.text);
			case 'ClassExpr':
				top_scope.set('class', id.text);
			case 'FunctionDecl':
				top_scope.set('function', id.text);
			case 'MethodDecl':
				switch expr_type:
					case 'StaticDecl':
						top_scope.set('statics', id.text);
						top_scope.set('static', id.text);
					case 'ProtoDecl', 'ClassExpr', 'InitDecl':
						top_scope.set('protos', id.text);
						top_scope.set('proto', id.text);
					default:
						if top_scope.type == 'ClassExpr':
							top_scope.set('protos', id.text);
							top_scope.set('proto', id.text);
						else:
							top_scope.set('function', id.text);
			default:
				return;
		scope.name = id.text;

	function checkIdentifierExpr(expr, ass, idexpr, id, scope, let_scope):
		if let_scope && let_scope.isDefined(id.text, 'let'):
			return;
		var forstam = let_scope && let_scope.type == 'ForStam' && /ForPConditionPatt|ForInConditionPatt/.test(expr.type);
		if ass && idexpr.index == 0:
			if forstam && ass.parent.index == 0:
				let_scope.set('let', id.text);
			else:
				if scope.isDefined( id.text, null, 1) == 'unknow':
					scope.set('modfiy', id.text, true);
				else if !/defined/.test( scope.isDefined( id.text ) ):
					scope.set('undefined', id.text);
		else if !scope.isDefined( id.text, null, 1 ):
			if forstam && idexpr.parent.index == 0:
				let_scope.set('let', id.text);
			else:
				scope.set('unknow', id.text);


module.exports = Scope;
