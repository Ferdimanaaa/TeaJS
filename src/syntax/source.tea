
class Source:

	var Splice  = Array.prototype.splice,
		Slice   = Array.prototype.slice,
		IndexOf = Array.prototype.indexOf;

	var Token = require "./token.js";
	var Location = require "./location.js";
	var PreProcess = require "../preprocess";

	constructor(source, file, ctx):
		if @.constructor != Source:
			return new Source(source, file, ctx);

		@.index    = 0;
		@.length   = 0;
		@.source   = null;
		@.fileName = null;
		@.context = ctx || PreProcess.context();
		if arguments.length:
			@.parse( source, file, @.context, true).clean();
		

	parse(text, file, ctx = @.context, init):

		if !file && ! /^["']/.test(text) && Path.isPathText(text):
			file = text, text = null;
		loc           = new Location( file, text );
		text          = loc.source;
		file          = loc.fileName;
		i             = 0;
		control_cache = {};
		if init || !@.source:
			@.source   = text;
			@.fileName = file;
	
		while i < text.length && (token = Token(text, i)):

			if token.error:
				Err token.error, [text, i, text[i], file];


			token.location = loc.fission(token.text, i);
			if @.length && @[-1].is('LF'):
				token.indent = token.type == 'BlankTokn' ? token.text.replace(/\t/g, tab_size).length : 0;
			
			switch code = token.text:
				case '"','"""','""""','`', "'", "'''", "''''":
					token = ctx.processor.string(@, text, i, token);

				case '/*', '#!', '//':
					token = ctx.processor.comm(@, text, i, token);

				case '/':
					token = ctx.processor.regexp(@, text, i, token);

				case '#':
					token = ctx.processor.pound(@, text, i, token, control_cache);
					
				default:
					if token.type == 'IdentifierTokn':
						token = ctx.processor.macro(@, text, i, token);
			
			if token as 'number':
				if token < 0: break;
				i = token;
			else:
				i = token.location.end + 1;
				@.add( token );
	
		return @;


	get text:
		return @.current.text;
	
	get type:
		return @.current.type;

	get current:
		return @.get(@.index);
		
	get peek:
		return @.get( @.nextIndex(@.index, true) );

	get prev:
		return @.get( @.prevIndex(@.index, true) );

	is():
		return @.current.is.apply(@[@.index], arguments);

	eq():
		return @.current.eq.apply(@[@.index], arguments);

	get(index):
		return @[index] || {};

	add(tok):
		if !tok || !tok.istoken:
			Err 'Add the wrong parameters('+isClass(tok)+'), Only to can add Lexeme object';
		@[@.length++] = tok;
		return @;

	back( opt, catch_comm ):
		while opt > 1:
			@.index = @.prevIndex(@.index, opt--, catch_comm);
		@.index = @.prevIndex(@.index, opt, catch_comm);
		return @;

	next( opt, catch_comm ):
		while opt > 1:
			@.index = @.nextIndex(@.index, opt--, catch_comm);
		@.index = @.nextIndex(@.index, opt, catch_comm);
		return @;

	nextIndex(index, ig_lf, catch_comm):
		return GoIndex(1, @, index, ig_lf, catch_comm);

	prevIndex(index, ig_lf, catch_comm):
		return GoIndex(-1, @, index, ig_lf, catch_comm);

	indexPair(s1, s2, index, not_throw_error):
		index = index ? @.index;
		var ab = IndexPair(@, s1, s2, index);
		if !ab && !not_throw_error:
			Err 'Source index pair miss "'+s2+'" token', @[index], 'Source error'
		return ab;

	indexLine(index):
		index = index ? @.index;
		var a = index, b = index, len = @.length-2;
		while a > len || (a > 0 && @[a-1] && @[a-1].type != 'LF'):
			a --;
		while b < len && (!@[b] || @[b].type != 'LF'):
			b ++;
		return [(a > len ? len : a), (b > len ? len : b), index];

	lineIndent(index):
		index = index ? @.index;
		while index >= 0:
			if  @[index] && @[index].indent >= 0:
				return @[index].indent;
			index --;
		return -1;

	trimIndent(a, b):
		@.length && TrimIndent(@, a, b);
		return @;

	indexOf():
		return IndexOf.apply(@, arguments);

	matchOf( re, index = 0):
		var a, b;
		if m = @.source.match(re):
			for i = index, tk -> @:
				if !tk: continue;
				if tk.start == m.index && tk.fileName == @.fileName:
					a = i;
				if tk.end == m.index+m[0].length && tk.fileName == @.fileName
					b = i;
				if a != null && b != null:
					return [a, b]

	delete (a, b = a):
		for var i=a; i <= b; i++:
			@[i] = null;
		return @;

	insert(pos, list):
		if arguments.length == 1:
			list = pos, pos = @.length;
		list = list.istoken ? [list] : Slice.call(list);
		var indent =  @.lineIndent(pos);
		for i, t <- list:
			if !t || t.type == 'EOT':
				Splice.call(list, i, 1);
			else indent > 0 && t.indent >= 0:
				t.indent += indent;
		list.unshift(pos, 0);
		Splice.apply(@, list);
		return @;

	clone(a, b):
		var src = new Source();
		a = typeof a != 'number' ? 0 : a;
		b = typeof b != 'number' ? @.length : b;
		for var i = a; i < b; i++:
			if @[i]:
				src.add(@[i]);
		if b != @.length:
			src.add(@[-1]);
		return src;

	clean():
		a = -1;
		for i, token -> @:
			if !token: continue;
			if token.type == 'EOT':
				@[i] = null;
			if token.is('LineHead'):
				a = i;
			if token.is('LF'):
				if a != -1:
					@.delete(a, i);
				a = -1;
				continue;
			if !token.is('BlankTokn'):
				a = -1;
		return @.refresh().add( Token('\4') );

	refresh():
		var target = @[@.index];
		var a = 0, del_i = -1, del_len = 0;

		for i, token <- @:
			if token:
				if del_len:
					Splice.call(@, del_i, del_len);
				del_i = -1, del_len = 0;
			else:
				del_i = i, del_len += 1;
		if del_len:
			Splice.call(@, del_i, del_len);

		if target != @[@.index]:
			@.index = @.indexOf(target);
		return @;

	join(a, b):
		if isArray(a):
			b = a[1], a = a[0];
		a = a < 0 ? @.length + a : (a || 0),
		b = b < 0 ? @.length + b : Math.min(b||Infinity, @.length);
		var texts = [];
		for var i=a; i <= b; i++:
			@[i] && @[i].text != '\4' -> texts.push( @[i].text );
		return texts.join('');

	function TrimIndent(src, a = 0, b = src.length-1):
		var _a = a, _b = b;
		// trim left blank
		while src[ _a ].is('BlankTokn', 'LF'):
			_a ++;
		if _a > a:
			if src[--_a].type != 'LF':
				_a--;
			src.delete(a, _a);
	
		// trim right blank
		while src[_b].is('BlankTokn', 'LF'):
			_b --;
		if _b < b:
			src.delete(++_b, b);

		// trim line indent
		var min = -1;
		for var i = a; i <= b; i++:
			if src[i] && src[i].indent >=0:
				if min == -1 || src[i].indent < min:
					min = src[i].indent;

		if min > 0:
			for var i = a; i <= b; i++:
				if src[i] && src[i].indent >= 0:
					src[i].indent -= min;
					if src[i].indent == 0:
						src[i+1].indent = src[i].indent;
						src[i++] = null;
					else if src[i].type == 'BlankTokn':
						src[i].text = src[i].text.replace(/\t/g, tab_size).substr(0, src[i].indent);
		return src;

	function GoIndex(ori, src, index, ig_lf, catch_comm):
		var len = src.length - 1, type;
		while (index += ori) >=0 && index <= len:
			type = src[index] && src[index].type;
			if !type || type == 'BlankTokn' || (!catch_comm && type == 'CommDecl') || (ig_lf && type == 'LF'):
				continue;
			return index;
		if ori > 0:
			return index > len ? len : index;
		return index < 0 ? 0 : index;

	function IndexPair(src, s1, s2, index):
		var s1_re = new RegExp('^'+s1.replace(/([^\w\|])/g, '\\$1')+'$'),
			s2_re = new RegExp('^'+s2.replace(/([^\w\|])/g, '\\$1')+'$');
		var len = src.length, a =- 1, jump = 0;
		while index < len:
			if src[index].text == '\\':
				index += 2;
				continue;
			if s1_re.test( src[index].text ):
				if a == -1:
					a = index;
				else if s1 == s2:
					return [a, index];
				else:
					jump += 1;
			else if s2_re.test( src[index].text ) && a != -1:
				jump == 0 && return [a, index];
				jump -= 1;
			index += 1;

module.exports = Source;