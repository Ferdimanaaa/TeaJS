
class Scope:
	
	scope_map    = {};
	decl_types   = ["function", "static", "proto", "name", 'class', 'argument'];

	constructor(type, node, parent):
		@.type      = type;
		@.target    = node;
		@.name      = null;
		@.variables = {};
		@.undefines = {};
		@.cache     = {};
		if @.type == 'Class':
			@.protos  = {};
			@.statics  = {};

		if parent:
			@.upper = parent;
			parent.subs |= [];
			parent.subs.push( @ );

	get valid:
		scope = @;
		while scope.type == 'Let':
			scope = scope.upper;
		return scope;

	get parent:
		upper = @.upper;
		while upper.type == 'Let':
			upper = upper.upper;
		return upper;

	get root:
		rot = @;
		while rot && rot.type != 'Root':
			rot = rot.upper;
		return rot;

	query (name):
		scope = @;
		while scope && (scope.type != name && scope.name != name ):
			if scope.type == 'Root' || scope.type == 'Global':
				return;
			scope = scope.upper;
		return scope;

	define(state, id, alias):
		if state.isToken || state.isSyntax:
			alias = id, id = state, state = null;
		if id.isToken:
			id = id.parent;
		if !state:
			state = checkScopeMap(id);
			if !alias && state == 'let':
				alias = 'l_$';
		if !state:
			return;

		if id.type == 'NameExpr':
			@.name = id[0].text;
		
		switch state:
			case 'name':
				@.name = id[0].text;

			case 'function', 'class':
				setDefine( @.parent, id, state, alias);

			case 'proto', 'static':
				if not scope = @.query('Class'):
					Err 1002, id;
				setDefine( scope, id, state, alias);

			case 'for_let':
				setDefine( @, id, state, alias);

			case 'let':
				if !alias && id.parent && id.query('LetStam'):
					alias = 'l_$';
				setDefine( @, id, state, alias);
			
			default:
				setDefine( @.valid, id, state, alias);
		return state;

	function setDefine(scope, ids, state, alias):
		variables = scope[state+'s'] || scope.variables;
		if ids as 'string':
			ids = [ {text:ids} ];

		for id => ids:
			text = id.text;
			if text in variables:
				exist = variables[text];
				if exist[0] == 'const':
					Err 1003, vars;
				if state == 'undefined' || state == 'unknow':
					continue;
			else if state == 'undefined' || state.indexOf('undefined') != -1:
				scope.undefines[text] = id.isToken ? id : text;

			variables[text] |= [undefined]
			variables[text][0] = state;
			if alias:
				variables[text][1] = alias.replace(/\$/g, text);

	state(target, level = 0):
		if state = @.check(target, level, true):
			return state[0];

	alias(target, level = 0):
		if state = @.check(target, level, true):
			return state[1];

	check(target, level = 0, not_define):
		[target, name] = checkTarget(target);
		scope = @;
		
		if name in scope.variables:
			return scope.variables[name];

		while scope.type == 'Let':
			scope = scope.upper;
			if name in scope.variables:
				return scope.variables[name];

		if level !== 1:
			if target && !not_define:
				state = checkScopeMap(target);
				if state && state != 'undefined' && state != 'unknow':
					return [@.define(state, target)];

			if level.isScope:
				stop = level;
				level = 0;
				
			_scope = null;

			while scope = scope.upper:
				if scope == stop && scope != _scope && --level:
					break;
				_scope = scope;
				if name in scope.variables:
					state = scope.variables[ name ];
					@.variables[name] = [ /undefined|defined|name/.test(state[0]) ? 'unknow' : state[0], state[1] ];
					return scope.variables[ name ];

			

			if state:
				return [@.define(state, target)];

	member(target):
		[target, name] = checkTarget(target);
		if cls = @.query('Class'):
			if name in cls.protos:
				return 'proto';
			if name in cls.statics:
				return 'static';

	cachePush(name, something):
		cache = @.cache;
		cache[name] |= [];
		cache[name].push(something);
		return cache[name];

	@::isScope = true;

	static init(ast, check_define, __scope):
		if !__scope:
			__scope   = new Scope( ast.is( 'Let', 'Class', 'Function', 'Root' ) || 'Root', ast );
			ast.scope = __scope;

		for i, node -> ast:

			if type = node.is( 'Let', 'Class', 'Function', 'Root'):
				node.scope = new Scope(type, node, __scope);
				@.init(node, check_define, node.scope);
			else:
				node.scope = __scope;

				if scope_map[ node.type ]:
					if type = checkScopeMap(node, scope_map[ node.type ]):
						if decl_types.indexOf( type ) != -1:
							__scope.define( type, node );
				if node.isSyntax:
					@.init(node, check_define, __scope);				

		return ast.scope;

	static defineScope( patt ):
		slices      = SText.split(patt, '->', true);
		compileScopeMap( slices.pop(), slices.reverse(), 0, scope_map );

	static test(node):
		return !!scope_map[node.type];

	function compileScopeMap(type, patt, index, __sub):
		names  = patt[index];

		if names[0] == '<':
			names = names.substr(1).trim();
			test  = true;
		else if /\<\-/.test(names):
			[top, names] = names.split('<-');
			top = top.trim().split(' ');

		names = names.trim().split(' ');
		for name => names:
			if m = name.match(/^(\w+)\[(\d+)\]$/):
				name = m[1];
				testIndex = m[2];

			sub = sub2 = null;
			if test:
				__sub[ name ] = __sub[ name ] || {};
				sub = __sub;
				if testIndex:
					__sub[ name ].testIndex = true;
					sub2 = __sub[ name ][testIndex] = __sub[ name ][testIndex] || {};
				else:
					sub2 = __sub[ name ].subs = __sub[ name ].subs || {};
			else:
				sub = __sub[ name ] = __sub[ name ] || {};
				if testIndex:
					__sub[ name ].testIndex = true;
					sub = __sub[ name ][ testIndex ] = __sub[ name ][ testIndex ] || {};		

			if top:
				__sub[ name ].tops = top;
				top.default = type;

			if index < patt.length - 1:
				compileScopeMap( type, patt, index+1, sub );
				if sub2:
					compileScopeMap( type, patt, index+1, sub2 );
			else if !top:
				__sub[ name ].default = type;

	function checkScopeMap(node, _map, _not_def):

		if !_map:
			if scope_map[ node.type ]:
				return checkScopeMap( node, scope_map[ node.type ]);
			return;

		if parent = node.parent:
			if parent.type == 'ArgusStam':
				parent = parent.parent;

			if parent && map = _map[ parent.type ]:
				if map.testIndex:
					index = node.index;
					if map[ index ]:
						if ref = checkScopeMap(parent, map[ index ], true) || map.default:
							return ref;
					return checkScopeMap(parent, map, true) || _map.default;
				return checkScopeMap(parent, map);

			if _map.tops:
				if parent.scope && _map.tops.indexOf( parent.scope.valid.type ) != -1:
					return _map.tops.default;
		
		if _map.subs:
			return checkScopeMap(node, _map.subs);
		


		if !_not_def && _map.default:
			return _map.default;

	function checkTarget(target):
		if target.isSyntax || target.isToken:
			name = target.text;
			if target.isToken:
				target = target.parent;
		else:
			name = target;
			target = null;
		return [target, name];

module.exports = Scope;
