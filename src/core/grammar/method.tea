
export SUGAR(src, params):
	if !@.prepor:
		return;
	if not map = @.prepor[params[0]]:
		if sugar = @.prepor.check(params[0]):
			if node = sugar.parse(@, src):
				return node;
		return;
	for name, sugar in map:
		if node = sugar.parse(@, src):
			return node;

export ROUTE(src, params):
	if params.length:
		for i, item -> params:
			item = item.replace(/\s*→\s*/, '→').split('→');
			if item.length == 2:
				params[ item[0] ] = item[1];
			else:
				params[ 'default' ] = item[0];
		params.length = 0;
	token = src.current;
	text  = token.text;
	patt  = text in params ? params[text] : params['default'];
	if patt:
		if text == patt:
			return token;

		if @.parser(patt):
			return @.parser(patt, src);

		if res = @.pattern(patt, src):
			return res;

export ISPARAM(src, argus):
	params = @.handle.params;
	if params && argus:
		for item => argus:
			if params.indexOf(item) != -1:
				return true;
	return false;

export IS(src, params):
	[index, yes, no] = checkIsMethodArgus(params, src);

	if not token = src[index]:
		return !yes && no ? true : false;
	
	text = token.text;
	types = token.types;
	if yes:
		for name => yes:
			if res = @.parser(name, src, null, true):
				return res;
			if types.indexOf(name) != -1 || name == text:
				if !no || (!token.is.apply(token, no) && name != text):
					return token;
	else if no:
		if !token.is.apply(token, no) && name != text:
			return token;
	else:
		Err 'params error', token;
	return false;

export INDENT(src, params):
	cache = @.handle.cache;
	while last = cache[-1]:
		if last.type == 'BlockNode':
			if last.subType == 'IndentBlock'
				check_indent = last.theIndent;
			break;
		cache = last;
	if check_indent != null && check_indent != src.lineIndent():
		return false;
	return true;

export CONCAT(src, params):
	a = params[0] || src.current.text;
	b = params[1];
	if a && a.isToken:
		a = a.text;
	if b && b.isToken:
		b = b.text;
	if a as 'string':
		if /\.{3}|\|| /.test(a) && a.length > 2:
			patt = a;
			a = src.index;
			if temp = @.pattern(patt, src, null, 'Temp'):
				b = src.index;
			else:
				return false;
		else if (ab = src.indexPair(a, b||a, src.index, true)) && ab[0] == src.index:
			a = ab[0];
			b = ab[1];
		else:
			return false;
	if a < b:
		types = params[2] && params[2].split(' ') || src.current.types.slice();
		src.index = b;
		token = src[a].clone( src.join(a, b), types);
		token.location.code = token.text;
		token.location.end = src[b].location.end;
		return token;
	return false;

function checkIsMethodArgus(argus, src):

	if argus.length == 1:
		mode = null, vals = argus[0], lf = argus[1];
	else:
		mode = argus[0], vals = argus[1], lf = argus[2];

	if mode as 'string':
		if not m = mode.trim().match(/([\+\-]{1,2})(\d+)/):
			Err '"" pattern error';
		mode = [m[1], parseInt(m[2])];

	if vals as 'string':
		temp = vals.split(' ');
		yes = [];
		no = [];
		for item => temp:
			if item[0] == '!':
				no.push( item.substr(1) );
			else:
				yes.push( item );
		vals = {yes: yes.length && yes, 
				no: no.length && no};
		argus[0] = mode;
		argus[1] = vals;

	index = src.index;
	if mode:
		num = mode[1];
		while --num >= 0:
			switch mode[0]:
				case '++':
					index ++;
				case '+': default:
					index = src.nextIndex( index, !lf);
				case '--':
					index --;
				case '-':
					index = src.prevIndex( index, !lf );

	return [index, vals.yes, vals.no];