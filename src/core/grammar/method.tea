
export SUGAR(src, params):
	if !@.prepor:
		return;
	if not map = @.prepor[params[0]]:
		if sugar = @.prepor.check(params[0]):
			if node = sugar.parse(@, src):
				return node;
		return;
	for name, sugar in map:
		if node = sugar.parse(@, src):
			return node;

export CHECK(src, params, config):
	if !config.test:
		params[2] = params[2].split(' ');
		config.test = true;
	left  = params[0]
	mark  = params[1];
	right = params[2];
	switch left:
		case 'last':
			last = @.handle.cache;
			while isArray(last):
				last = last[-1];
		default:
			last = @.handle.cache[left];
	if last && last.is:
		switch mark:
			case "==":
				return !!last.is.apply(last, right);
			case "===":
				return right.indexOf(last.type) != -1 || right.indexOf(last.text) != -1;
			case "!=":
				return !last.is.apply(last, right);
			case "!==":
				return right.indexOf(last.type) == -1;
	return false;

export ARGU(src, argus, config):
	config.test = true;
	params = @.handle.params;
	if params && argus:
		for item => argus:
			if params.indexOf(item) != -1:
				return true;
	return false;

export IS(src, params, config):
	if !params.mode:
		if m = params[0].match(/^([\+\-]{1,2})(\d+)/):
			params.mode = [m[1], parseInt(m[2]), 0];
			params.shift();
		else:
			params.mode = [0, 0, 0];
		if params.mode[1]:
			config.test = true;
	index = moveIndex(src, params.mode);
	if not token = src[index]:
		return false;
	if params.indexOf( token.text ) != -1:
		return token;
	if token.is.apply(token, params):
		return token;
	return false;

export NOT(src, params, config):
	if !params.mode:
		if m = params[0].match(/^([\+\-]{1,2})(\d+)/):
			params.mode = [m[1], parseInt(m[2]), 0];
			params.shift();
		else:
			params.mode = [0, 0, 0];
		if params.mode[1]:
			config.test = true;
	index = moveIndex(src, params.mode);
	if not token = src[index]:
		return false;
	if params.indexOf( token.text ) != -1:
		return false;
	if token.is.apply(token, params):
		return false;
	return token;

export INDENT(src, params):
	cache = @.handle.cache;
	while last = cache[-1]:
		if last.type == 'BlockNode':
			if last.subType == 'IndentBlock'
				check_indent = last.theIndent;
			break;
		cache = last;
	if check_indent != null && check_indent != src.lineIndent():
		return false;
	return true;

export CONCAT(src, params):
	a = params[0] || src.current.text;
	b = params[1];
	if a && a.isToken:
		a = a.text;
	if b && b.isToken:
		b = b.text;
	if a as 'string':
		if /\.{3}|\|| /.test(a) && a.length > 2:
			patt = a;
			a = src.index;
			if temp = @.pattern(patt, src, null, 'Temp'):
				b = src.index;
			else:
				return false;
		else if (ab = src.indexPair(a, b||a, src.index, true)) && ab[0] == src.index:
			a = ab[0];
			b = ab[1];
		else:
			return false;
	if a < b:
		types = params[2] && params[2].split(' ') || src.current.types.slice();
		src.index = b;
		token = src[a].clone( src.join(a, b), types);
		token.location.code = token.text;
		token.location.end = src[b].location.end;
		return token;
	return false;

function moveIndex(src, data):
	index = src.index;
	if data:
		num   = data[1];
		while --num >= 0:
			switch data[0]:
				case '++':
					index ++;
				case '+': default:
					index = src.nextIndex( index, !data.lf);
				case '--':
					index --;
				case '-':
					index = src.prevIndex( index, !data.lf);
	return index;