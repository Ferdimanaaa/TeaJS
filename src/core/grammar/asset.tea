
export default class Asset:
		
	Method = require "./method.js";
	Token  = require "../token.js";

	cache       = Jsop.data();
	conf_pack   = {
		"@@=" : "rename pattern"
		"@@"  : "pattern name"
		"@="  : "rename response"
		"@?"  : "check response"
		"@~"  : "packing matched"
		"@:"  : "response name"
		"@!"  : "check empty" };
	conf_set    = {
		"\\n" : "lf"
		"∆"  : "error"
		"∅"  : "ig"
		"→"  : "test"
		"+?" : "smallest mode"
		"*?" : "smallest mode"
		"+"  : "mode"
		"*"  : "mode"
		"?"  : "mode"
		"!"  : "mode" };
	conf_re     = new RegExp(
		'(?:('+SText.re(Object.keys(conf_set))+'|∆(\\d*))|'+
		   '('+SText.re(Object.keys(conf_pack))+')([A-Za-z]{3,}))$');

	constructor(str):
		@.config  = { mode : '' };
		@.type    = null;
		@.content = null;
		@.param   = null;
		@.string  = str;
		if str:
			str = checkConfig(@, str);
			if str == '*':
				@.type = '*';
				@.content = str;
			else:
				checkPairAsset  (@, str) ||
				checkSetAsset   (@, str) ||
				checkMethodAsset(@, str) ||
				checkSubAsset   (@, str) ||
				checkNodeAsset  (@, str) ||
				checkCodeAsset  (@, str);

	parse(src, grm):
		switch @.type:
			case '*':
				return src.current;
			case 'Codes Test', 'Code Test':
				return parseCodeAsset.call(@, src, grm);
			case 'Pair Test':
				return parsePairAsset.call(@, src, grm);
			case 'Set Test':
				return parseSetAsset.call(@, src, grm);
			case 'Method Test':
				return parseMethodAsset.call(@, src, grm);
			case 'Node Test':
				return parseNodeAsset.call(@, src, grm);
			case 'Sub':
				return;

	@::isAsset = true;

	static compile(str):
		if !cache[str]:
			return cache[str] = new Asset(str);
		return cache[str];

	static parse(asset, src, grm):
		if !asset.isAsset:
			asset = Asset.compile(asset);
		return asset.parse(src, grm);

	// compile asset 

	function checkConfig(self, str):

		config = self.config;
		while m = str.match( conf_re ):
			if m.index == 0:
				break;

			if (m.index === 1 && str[0] === '\\'):
				if m[0].length > 1 && m[1] && !m[2]:
					m.index += 1;
					m[1] = m[1].substr(1);
				else:
					break;

			if m[1]:
				if m[2]:
					config.error = parseInt( m[2] );
				else:
					name = conf_set[m[1]];
					if name == 'smallest mode':
						config.smallest = true;
						config.mode = m[1][0];
					else:
						config[name] = m[1];
			else if m[3]:
				config.pack = conf_pack[ m[3] ];
				config.name = m[4];
			str = str.substr(0, m.index );
		return str;

	function checkPairAsset(self, str):
		if m = str.match(/^([^\. \(]+?)\.\.\.([^\. ]+)$/):
			self.type    = 'Pair Test';
			self.content = [
				SText.cleanESC(m[1]), 
				SText.cleanESC(m[2])
			];
			return true;

	function checkSetAsset(self, str):
		if m = str.match(/^\[(.*?)\]$/):
			str = m[1];
			if /[^\\],/.test(str):
				list = SText.split( str, ',', 'params', true);
			else:
				list = SText.split( str, ' ', true, true);

			for i <- list:
				key  = i;
				patt = list[i];
				if patt.indexOf('→') > 0:
					temp = patt.split('→');
					key  = temp[0].trim();
					patt = temp[1].trim();
					list.splice(i, 1);
					list.__HasKey__ = true;

				list[key] = { patt:patt };
				if /^[A-Z][A-Za-z]+$/.test(patt):
					list[key].__TestNode__ = true;
				else if /[a-z]+/i.test(patt) && /\W+/.test(patt):
					list[key].__TestPatt__ = true;

			self.type = 'Set Test';
			self.content = list;
			return true;

	function checkMethodAsset(self, str):
		if m = str.match(/^#(\w+)(?:\((.*?)\))?$/):
			self.type    = 'Method Test';
			self.content = m[1];
			self.param   = m[2] ? SText.split( m[2], ',', 'params', true) : [];
			return true;

	function checkSubAsset(self, str):
		if str[0] == '(' && str[-1] == ')':
			str = str.slice(1, -1);
			if m = str.match( /^(\?\!|\?\=|\?\:)/ ):
				switch m[1]:
					case '?:': self.config.ig = true;
					case '?!': self.config.mode = '!';
					case '?=': self.config.test = true;
				str = str.substr( m[0].length );
			self.type    = 'Sub';
			self.content = str;
			return true;

	function checkNodeAsset(self, str):
		if /^[A-Z]\w+$/.test(str):
			self.type = 'Node Test';
			self.content = str;
			return true;

	function checkCodeAsset(self, str):
		str        = SText.cleanESC(str);
		if /^\w+$|\W/.test(str):
			self.type = 'Code Test';
			self.content = str;
			return true;

		token_list = Token.tokenize( str, 0, 'code list');
		if token_list.length == 1:
			self.type = 'Code Test';
			self.content = token_listp[0];
		else:
			self.type = 'Codes Test';
			self.content = token_list;
		return true;

	// parse asset

	function parseSetAsset(src, grm):
		token   = src.current;
		text    = token.text;
		types   = token.types;
		content = @.content;
		if content.__HasKey__:
			if types[0] != 'NUMBER' && text in content:
				content = [content[text]];
			else:
				for type => types:
					if type in content:
						content = [content[type]];
						break;
		
		for i, item -> content:
			patt = item.patt;
			if token.text == patt || types.indexOf(patt) != -1:
				return token;
			if item.__TestNode__:
				if ref = grm.parser(patt, src, null , true):
					return ref;
			else if item.__TestPatt__:
				if ref = grm.pattern(patt, src):
					return ref;

	function parsePairAsset(src, grm):
		[s1, s2] = @.content;
		if ab = src.indexPair(s1, s2, src.index, true):
			if ab[0] == src.index:
				list = Jsop.toArray(src, ab[0], ab[1]+1);
				src.index = ab[1];
				return list;
		return false;

	function parseCodeAsset(src, grm):
		if @.type == 'Code Test':
			return @.content == src.current.text ? src.current : false;

		code_list = @.content;
		index     = src.index - 1;
		list      = [];
		for code => code_list:
			token = src[ ++ index];
			if !token || (code != token.text && (!token.is('BLANK') || !/^\s+$/.test(code))):
				return false;
			list.push( token );
		if list.length:
			src.index = index;
			return list;
		return false;

	function parseNodeAsset(src, grm):
		name  = @.content;
		token = src.current;
		if token.types.indexOf( name ) != -1:
			return token;
		if grm.prepor && ref = grm.prepor.check(name, null, src, grm):
			return ref;
		if grm.parser(name):
			return grm.parser(name, src, @.param);
		if name == token.text:
			return token;
		return false;

	function parseMethodAsset(src, grm):
		name =  @.content;
		if name in Method:
			return Method[name].call(grm, src, @.param, @.config);
		if grm.parser(name):
			return grm.parser(name, src, @.param);
		Err 4002, name, grm.handle.name;
