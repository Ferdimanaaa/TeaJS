
Asset = null;
Card = require "../card";

export EACH(node, params):
	if /^\d$/.test( params[i = 0] ):
		index = parseInt( params[i++] );
	else:
		index = 0;

	if /#|@/.test( params[i] ):
		patt = params[i++];

	if params[i] && /. \-\-\> ./.test(params[i]):
		rep = SText.split( params[i++], '\-\-\>', true, true );

	if params[i]:
		sep = params[i++];

	list = [];
	for index, item -> node:
		if patt:
			item = @.pattern( patt.replace(/\$/g, index), item );
		else:
			if rep && item.isToken && rep[0] == item.text:
				item = rep[1];
			else:
				item = @.read( item );
		if item:
			list.push( item );
			if sep:
				list.push( sep );
	if sep && list[-1] == sep:
		list.pop();
	return list;

export COMMA(node, params):
	params = ( params||[] ).concat([', ']);
	list = EACH.call(@, node, params);
	return new Card('CommaExpr', list );

export INSERT(node, params):
	name  = params[0];
	asset = checkAsset(params[1], node, @);
	type  = params[2];
	scope = type && node.scope.query(type) || node.scope;
	scope.cachePush( name, asset );
	return true;

export HEAD(node, params):
	return INSERT.call(@, node, ['head', params[0], params[1]]);

export END(node, params):
	return INSERT.call(@, node, ['end', params[0], params[1]]);

export CHECK(node, params):
	if not state = node.scope.check( node ):
		return node.scope.define(node);
	return state[0];

export STATE(node, params):
	if params.length:
		state   = params[0];
		target = checkAsset(params[1], node, @);
		alias  = params[2];
		return node.scope.define(state, target, alias);
	else:
		return node.scope.state( node);

export ALIAS(node, params):
	if text = node.scope.alias(node):
		token = node.tokens(0).clone(text);
		return token;
	else:
		return node;

export CONST(node, params):
	text = node.text;
	if node.parent.type == 'AssignExpr':
		return text;

	scope = node.scope.root;
	scope.consts |= {};
	if scope.consts[text]:
		return scope.consts[text];
	else:
		scope.consts[text] = checkVariable('_rg_', scope);
		cache = scope.cache;
		cache.head |= [];
		cache.head.push( scope.consts[text]+' = '+text );
		return scope.consts[text];

export VALUE(node, params):
	if !params || !params.length:
		// return node.is('Value', 'Operate') ? @.read(node) : @.pattern('(@)', node);
		return node.is('AssignExpr') ? @.pattern('(@)', node) : @.read(node);

	name = params[0];
	if /@|#/.test(name):
		ref = checkAsset(name, node, @);
		// if node.parent.is('AssignExpr'):
		// 	return ref.insert(0, '(').add(')');
		return ref;

	if node.type in ['VariableExpr', 'AccessExpr', 'IDENTIFIER']:
		return @.handle.variables[name] = node;
	_name = checkVariable(name, node.scope, node);
	@.handle.variables[name] = _name;
	return @.pattern('(@'+name+' = @)', node);

export LIST(node, params):
	list = [];
	for i -> params:
		ref = @.pattern(params[i], node);
		if isArray(ref):
			list.push.apply(list, ref);
		else:
			list.push(ref);
	return list;

export VAR(node, params):
	type = params[0];
	name = params[1];
	if !name:
		name = type, type = 'undefined';
	_name = checkVariable(name, node.scope, node, type);
	if asset = params[2]:
		if /#|@/.test(asset):
			asset = checkAsset(asset, node, @);
		if asset:
			node.scope.define(type, asset, _name);
	return @.handle.variables[name] = _name;

export STR(node, params):
	if node.is( 'STRING' ):
		return node;
	return @.pattern('"@"', node);

export DEL(node, params):
	node.parent[node.index] = null;
	return true;

export CARD(node, params):
	type = params[0];
	if params[1]:
		node = checkAsset(params[1], node, @);
	list = [];
	for i -> node:
		if node[i]:
			if node[i].isNode:
				list.push( @.read(node[i]) );
			else:
				list.push( node[i] );
	if list.length:
		switch type:
			case 'var':
				card = @.pattern('var #COMMA(@)', list);
				card.type = 'VarStam';
				return card;
			default:
				return new Card(type || 'Line', list);


function checkAsset(text, node, std):
	Asset |= require "./asset.js";
	if m = Asset.test(text):
		if m[0] == text:
			return Asset.parse(text, node, std);
		return std.pattern(text, node);
	return text;

function checkVariable(name = 'i', scope, node, type, deep = true):
	if name.length == 1:
		name_map = ['i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'k', 'y', 'z'];
		i = name_map.indexOf(name);
	else:
		i = 0;
	_name = name;
	while state = checkExist( _name, scope, deep ):
		if state == 'undefined ref':
			break;
		if name_map:
			_name = name_map[++i];
		else:
			_name = name+(i++);

	if node.parent.is('Assign'):
		node = node.parent;
	if node.parent.is('ArgusStam'):
		node = node.parent;
	if node.is('VarStam', 'LetStam', 'ConstStam') || node.parent.is('VarStam', 'LetStam', 'ConstStam'):
		return _name;
	scope.define( type || 'undefined', _name);
	return _name;

function checkExist(name, scope, deep):
	if state = scope.state(name):
		return state;
	if deep && node = scope.target:
		node.each(function(target, indexs){
			type = target.type;
			if target.is('Function') || type == 'MemberExpr':
				return 0;
			if type == 'IDENTIFIER' || type == 'KEYWORD':
				if target.text == name:
					state = 'unknow';
					return false;
		});
	return state;
