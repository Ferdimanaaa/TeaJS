var Tokens   = require "../tokens";

class Source:

	var Splice    = Array.prototype.splice,
		Slice     = Array.prototype.slice,
		IndexOf   = Array.prototype.indexOf;

	constructor(source, file):
		@.index    = 0;
		@.length   = 0;
		@.source   = source;
		@.fileName = file;
		@.preProcessor = null;

	get text:
		return @.current.text;
	
	get type:
		return @.current.type;

	get current:
		return @.get(@.index);
		
	get peek:
		return @.get( @.nextIndex(@.index, true) );

	get prev:
		return @.get( @.prevIndex(@.index, true) );

	is():
		return @.current.is.apply(@[@.index], arguments);

	eq():
		return @.current.eq.apply(@[@.index], arguments);

	get (index):
		return @[index] || {};

	add (tok):
		if !tok || !tok.istoken:
			Err 'Add the wrong parameters('+isClass(tok)+'), Only to can add Lexeme object';
		@[@.length++] = tok;

	back( opt, catch_comm ):
		while opt > 1:
			@.index = @.prevIndex(@.index, opt--, catch_comm);
		@.index = @.prevIndex(@.index, opt, catch_comm);
		return @;

	next( opt, catch_comm ):
		while opt > 1:
			@.index = @.nextIndex(@.index, opt--, catch_comm);
		@.index = @.nextIndex(@.index, opt, catch_comm);
		return @;

	nextIndex(index, ig_lf, catch_comm):
		return GoIndex(1, @, index, ig_lf, catch_comm);

	prevIndex(index, ig_lf, catch_comm):
		return GoIndex(-1, @, index, ig_lf, catch_comm);

	// ----

	indexPair(s1, s2, index, reverse, not_throw_error):
		index = index ? @.index;
		var ab = IndexPair(@, s1, s2, index, reverse);
		if !ab && !not_throw_error:
			Err 'Source index pair miss "'+s2+'" token', @[index], 'Source error'
		return ab;

	indexLine(index):
		index = index ? @.index;
		var a = index, b = index, len = @.length-2;
		while a > len || (a > 0 && @[a-1] && @[a-1].type != 'LF'):
			a --;
		while b < len && (!@[b] || @[b].type != 'LF'):
			b ++;
		return [(a > len ? len : a), (b > len ? len : b), index];

	lineIndent(index):
		index = index ? @.index;
		while index >= 0:
			if  @[index] && @[index].indent >= 0:
				return @[index].indent;
			index --;
		return -1;

	trimIndent(a, b):
		@.length && TrimIndent(@, a, b);
		return @;

	// ----

	indexOf():
		return IndexOf.apply(@, arguments);

	delete(a, b = a):
		for var i=a; i <= b; i++:
			@[i] = null;
		return @;

	insert(pos, list):
		list = list.istoken ? [list] : Slice.call(list);
		var indent =  @.lineIndent(pos);
		for i, t <= list:
			if !t || t.type == 'EOT':
				Splice.call(list, i, 1);
			else indent > 0 && t.indent >= 0:
				t.indent += indent;
		list.unshift(pos, 0);
		Splice.apply(@, list);
		return @;

	clone(a, b):
		var src = new Source();
		a = typeof a != 'number' ? 0 : a;
		b = typeof b != 'number' ? @.length : b;
		for var i = a; i < b; i++:
			if @[i]:
				src.add(@[i]);
		src.add(Tokens.endToken);
		return src;

	refresh():
		var target = @[@.index];
		var a = 0, del_i = -1, del_len = 0;
		for i, token <= @:
			if token:
				if del_len:
					Splice.call(@, del_i, del_len);
				del_i = -1, del_len = 0;
			else:
				del_i = i, del_len += 1;
		if del_len:
			Splice.call(@, del_i, del_len);

		if target != @[@.index]:
			@.index = @.indexOf(target);
		return @;

	join(a, b):
		if isArray(a):
			b = a[1], a = a[0];
		a = a < 0 ? @.length + a : (a || 0),
		b = b < 0 ? @.length - 1 + b : Math.min(b||Infinity, @.length-2);
		var texts = [];
		for var i=a; i <= b; i++:
			@[i] -> texts.push( @[i].text );
		return texts.join('');


	static parse(text, file):
		if !file && ! /^["']/.test(text) && Path.isPathText(text):
			file = text, text = null;

		var loc = Tokens.location(file, text);
		var src = new Source(loc.source, loc.fileName);
		var i = 0;
		var token_re = /#token\s*(\w+(?:\s*,\s*\w+)*)\s*(.*?)(?:\n|$)/mg;

		file = src.fileName;
		text = src.source;
		while i < text.length && token = Tokens.parse(text, i):
			if token as 'string':
				Err token, [text, i, text[i], file];

			if token.text == '#token':
				token_re.lastIndex = i;
				if (m = token_re.exec(text)) && i == m.index :
					var types = Text.split(m[1], ',', true),
						symbols = Text.split(m[2], ',', true);
					Tokens.define(types, symbols);
					i += m[0].length;
					prep_log '[Prep define token: g{"'+symbols.join('","')+'"}]', token;
					continue;
				else:
					token.location = loc.fission(token.text, i);
					Err 501, token;

			token.location = loc.fission(token.text, i);
			if token.location.columnNumber === 0:
				token.indent = token.type == 'BlankTokn' ? token.text.replace(/\t/g, tab_size).length : 0;
			i = token.location.end + 1;
			src.add( token );

		src.add( Tokens.endToken );
		return src;

	function TrimIndent(src, a = 0, b = src.length-1):
		var _a = a, _b = b;
		// trim left blank
		while src[ _a ].is('BlankTokn', 'LF'):
			_a ++;
		if _a > a:
			if src[--_a].type != 'LF':
				_a--;
			src.delete(a, _a);
	
		// trim right blank
		while src[_b].is('BlankTokn', 'LF'):
			_b --;
		if _b < b:
			src.delete(++_b, b);

		// trim line indent
		var min = -1;
		for var i = a; i <= b; i++:
			if src[i] && src[i].indent >=0:
				if min == -1 || src[i].indent < min:
					min = src[i].indent;

		if min > 0:
			for var i = a; i <= b; i++:
				if src[i] && src[i].indent >= 0:
					src[i].indent -= min;
					if src[i].indent == 0:
						src[i+1].indent = src[i].indent;
						src[i++] = null;
					else if src[i].type == 'BlankTokn':
						src[i].text = src[i].text.replace(/\t/g, tab_size).substr(0, src[i].indent);
		return src;

	function GoIndex(ori, src, index, ig_lf, catch_comm):
		var len = src.length - 1, type;
		while (index += ori) >=0 && index <= len:
			type = src[index] && src[index].type;
			if !type || type == 'BlankTokn' || (!catch_comm && type == 'CommDecl') || (ig_lf && type == 'LF'):
				continue;
			return index;
		if ori > 0:
			return index > len ? len : index;
		return index < 0 ? 0 : index;

	function IndexPair(src, s1, s2, index, reverse):
		var s1_re = new RegExp('^'+s1.replace(/([^\w\|])/g, '\\$1')+'$'),
			s2_re = new RegExp('^'+s2.replace(/([^\w\|])/g, '\\$1')+'$');
		if reverse:
			var b = -1, jump = 0;
			while index >= 0:
				if s2_re.test( src[index].text ):
					if b == -1:
						b = index;
					else if s1 == s2:
						return [index, b];
					else:
						jump += 1;
				else if s1_re.test( src[index].text ) && b != -1:
					jump == 0 && return [index, b];
					jump -= 1;
				index -= 1;
		else:
			var len = src.length, a =- 1, jump = 0;
			while index < len:
				if s1_re.test( src[index].text ):
					if a == -1:
						a = index;
					else if s1 == s2:
						return [a, index];
					else:
						jump += 1;
				else if s2_re.test( src[index].text ) && a != -1:
					jump == 0 && return [a, index];
					jump -= 1;
				index += 1;

module.exports = Source;