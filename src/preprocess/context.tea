
class Context:
	require "./processor.js", "./macro.js", "./sugar.js";
	var DefPor, Syntax, Require, ReWriter;

	constructor(argv, extend):
		Syntax |= require "../syntax";
		Require |= require "./require";
		ReWriter |= require "../rewriter";

		@.macro      = {map:[]};
		@.macrofun   = {map:[]};
		@.statement  = {map:[]};
		@.expression = {map:[]};
		@.argv       = argv || {};
		@.processor  = new Processor(@);

		if DefPor:
			@.extends(DefPor);

		if extend:
			@.extends(extend);

	get length:
		return @.macro.map.length + @.macrofun.map.length +@.statement.map.length +@.expression.map.length;

	get source:
		if !@._source:
			if @.argv.source:
				@._source = @.argv.source;
			else if @.argv.text || @.argv.file:
				@._source = @.parse(@.argv.text, @.argv.file);
		return @._source;

	get fileName:
		return @.source.fileName;

	get sourceText:
		return @.source.source;

	get ast:
		if !@._ast:
			@._ast = Syntax.parse(@.source, @);
		return @._ast;

	get scope:
		return @.ast.scope;

	get rewriter:
		if !@._rewriter:
			@._rewriter = ReWriter.read(@.ast, @);
		return @._rewriter;

	get text:
		return @.rewriter.text;

	get sourcemap:
		map = ReWriter.sourceMap();
		map.file = @.argv.out || '';
		map.sourceRoot = @.fileName;
		map.parse( @.rewriter, @.source );
		return map;

	get requires:
		if !@._rewriter:
			@._rewriter = ReWriter.read(@.ast, @);
		return @.scope.requires;

	parse( text, file ):
		return Syntax.source(text, file, @);

	clone(argv, extend):
		ctx = new Context(argv, extend);
		ctx.extend(@);
		return ctx;

	undef (name):
		for type => ['macrofun', 'macro', 'statement', 'expression']:
			if (i = @[type].map.indexOf(name)) >= 0:
				@[type].map.splice(i, 1);
				delete @[type][name];

	add (something):
		if something as 'string':
			if something == 'expression' || something == 'statement':
				something = new Sugar(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], @);
			else:
				something = new Macro(arguments[0], arguments[1], arguments[2], @);

		var key = something.name, type = something.type;
		@[type][key] = something;
		if @[type].map.indexOf(key) == -1:
			@[type].map.push(key);
		return something;

	get (key):
		@.length || return;
		var limits = arguments.length > 1 ? Hash.slice(arguments, 1) : ['macrofun', 'macro', 'statement', 'expression'];
		for type => limits:
			if @[type].map.indexOf(key) != -1:
				return @[type][key];

	extends(extend):
		for type => ['macrofun', 'macro', 'statement', 'expression']:
			for key => extend[type].map:
				@.add( extend[type][key] );

	reinit():
		@._source   = null;
		@._ast      = null;
		@._rewriter = null;

	echo ( output, outmap ):
		output |= @.argv && @.argv.out;
		if @.requires.length:
			requires = Require.load( @.requires );
			Require.join( requires, @.rewriter );
		text = @.rewriter.text;
		if output:
			if outmap:
				sourcemap = @.sourcemap;
				if not outmap as 'string':
					outmap = output.replace(/\.\w+$/, '.map');
				Text.writeFile( sourcemap.text, outmap );
				text += '\n//# sourceMappingURL='+Path.relative(Path.dirname(output), outmap);
			Text.writeFile( text, output );
		return text;

	static defaultProcessor():
		DefPor |= new Context();
		for i, item -> arguments:
			if item:
				DefPor.extends( item as 'string' ? @.parseByFile(item) : item );

	static parseByFile(file, ctx):
		ctx ?= new Context();
		ctx.parse( file );
		return ctx;

	function loadRequiresList( list, cache ):
		for file, key in list:
			if file == 'length' || file in cache:
				continue;
			tea_log '** require file: '+file;
			var ctx = new Context( {file: file} );
			cache[file] = [key, ctx, ctx.rewriter];
			if ctx.requires.length:
				loadRequiresList( ctx.requires, cache );
		return cache;

module.exports = Context;
