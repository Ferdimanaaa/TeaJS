var Parser = require "./parser.js";
var Source = require "./source.js";
var Template = require "./template.js";

class PreProcessor:

	constructor(extend):
		@.macro      = {map:[]};
		@.macrofun   = {map:[]};
		@.statement  = {map:[]};
		@.expression = {map:[]};
		@.tests      = [];
		if extend:
			@.extends(extend);

	get length:
		return @.macro.map.length + @.macrofun.map.length +@.statement.map.length +@.expression.map.length;

	parse (src, not_compile):
		if src as 'string':
			src = Source.parse(src);
		for i, token => src:
			if !token:
				continue;
			switch token.type:
				case 'InstructionExpr':
					Parser.instruction.call(@, src, i, token);
				case 'IdentifierTokn':
					if !not_compile:
						Parser.compileMacro.call(@, src, i, token);
				case 'StringTokn':
					var text = token.text,
						re = /([^\\]|^)(\#\{(\w+)(.*?)\})/g;
					if !not_compile:
						while m = re.exec(text):
							if macro = m[4] ? @.get(m[3], 'macrofun') : @.get(m[3], 'macro'):
								if val = macro.getValue( m[4] ):
									text = text.slice(0, m.index+(m[1]?1:0)) + val + text.substr(re.lastIndex);
									re.lastIndex = m.index;
					token.text = Template.parseString(text);	
				case 'RegExpDecl':
					token.text = Template.parseRegExp(token.text);
		src.index = 0;
		src.refresh();
		return src;

	undef (name):
		for type ==> ['macrofun', 'macro', 'statement', 'expression']:
			if (i = @[type].map.indexOf(name)) >= 0:
				@[type].map.splice(i, 1);
				delete @[type][name];

	add (something):
		if something as 'string':
			if something == 'expression' || something == 'statement':
				something = new SyntacticSugar(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
			else:
				something = new Macro(arguments[0], arguments[1], arguments[2]);
		var key = something.name, type = something.type;
		@[type][key] = something;
		if @[type].map.indexOf(key) == -1:
			@[type].map.push(key);
		return something;

	get (key):
		@.length || return;
		var limits = arguments.length > 1 ? Hash.slice(arguments, 1) : ['macrofun', 'macro', 'statement', 'expression'];
		for type ==> limits:
			if @[type].map.indexOf(key) != -1:
				return @[type][key];

	extends(extend):
		for type ==> ['macrofun', 'macro', 'statement', 'expression']:
			for key ==> extend[type].map:
				@.add( extend[type][key] );

	matchNode(type, src, opt):
		@[type] || return;
		var map = @[type].map, _index = src.index;
		for i, name => map:
			src.index = _index;
			if exp = @[type][name].parse(src, opt):
				prep_log '[Prep '+type+': '+name+' matched]', src[_index];
				return exp;

class Macro:
	var cache = {};
	var Template   = require "./template.js";

	constructor(name, params, body):
		@.name = name;
		var params_key = params && params.join('').trim() || '',
			key = params_key+body;
		if cache[key]:
			@.type   = cache[key].type;
			@.params = cache[key].params;
			@.body   = cache[key].body;
			@.script = cache[key].script;
		else:
			@.type   = params ? 'macrofun' : 'macro';
			@.params = params_key ? params : [];
			@.body   = body;
			if (/#script/).test(body):
				try:
					var script = Template.textScript(body, params);
					@.script = eval('('+script+')');
				catch e:
					@.error = e;
			cache[key] = @;

	getValue(params, src):
		if params:
			params = Text.split( params.replace(/^\((.*)\)$/g, '$1') , ',', 'trim');
		if @.script:
			value = @.script.apply({self:@, src:src}, params || []);
		else:
			value = @.body;

		value = replaceParam(value, @.params||[], params||[]);
		return Text.trimIndent(value);

	function replaceParam(value, keys, params):
		var keys_join = keys.join('|');
		var re = new RegExp('(#*?)('+(keys_join ? '\\b(?:'+keys_join+')\\b|' : '')+'#(\\d+)|\\bARGR\\.\\.\\.)(##)?', 'g');
		var m, hash, unhash, key, num, arg, val, insert = [], id;

		while m = re.exec(value):
			hash = m[1], key = m[2], num = m[3], unhash = m[4];
			num = num || keys.indexOf(key);
			if key == 'ARGR...':
				val = params.slice(keys.length).join(', ');
			else if params[num]:
				val = params[num];

			id = '$$$'+ID()+'$$$';
			insert.push([id, (val ? hash%2 ? '"'+val+'"' : val : '')]);
			value = value.slice(0, m.index)+id+value.substr(re.lastIndex);
			re.lastIndex = m.index+id.length;
		for i => insert:
			value = value.replace(insert[i][0], insert[i][1]);
		return value;

class SyntacticSugar:

	var Syntax     = require "../syntax";
	
	constructor(type, name, pattern, writer, parser):
		@.type  = type;
		@.name  = name;
		@.stxre = Syntax.regexp(pattern);
		@.parser = parser;
		@.writer = writer;

	parse (src, opt):
		var node = Syntax.matchNode(@.name, @.stxre, src, 'ret node');
		if node && @.parser:
			return @.parser.call(@, node, src, opt);
		return node;

	read (reader, node):
		var write = reader.new(@.name);
		if @.writer as 'string':
			write.read(@.writer, node);
		else:
			write = @.writer(node, write) || write;
		return write;

module.exports = PreProcessor;