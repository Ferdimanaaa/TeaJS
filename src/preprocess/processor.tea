class Processor:
	var include_cache = {};
	var Template      = require "./template.js";

	constructor(ctx):
		@.context = ctx;

	string(src, text, i, token):
		return Processor.string(@.context, src, text, i, token);

	comm(src, text, i, token):
		return Processor.comm(@.context, src, text, i, token);

	regexp(src, text, i, token):
		return Processor.regexp(@.context, src, text, i, token);

	pound(src, text, i, token, control_cache):
		return Processor.pound(@.context, src, text, i, token, control_cache);
					
	macro(src, text, i, token):
		return Processor.macro(@.context, src, text, i, token);

	matchNode(type, src, opt):
		@.context[type] || return;
		var map = @.context[type].map, _index = src.index;
		for i, name -> map:
			src.index = _index;
			if exp = @.context[type][name].parse(src, opt):
				prep_log '[Prep '+type+': '+name+' matched]', src[_index];
				return exp;

	static string( ctx, src, text, i, token ):
		if (b = indexRight(text, i, token.text) ) === false:
			Err 'tokenize string pattern error! miss right token', token;
		str = text.slice(i, b+1);

		re = /([^\\]|^)(\#\{((\w+)(.*?))\})/g;
		while m = re.exec(str):
			val = parseMacro( ctx, null, m[3], 0, null, m[4] );
			str = str.slice(0, m.index+1)+(val || '')+str.substr(m.index+m[0].length);
			re.lastIndex = m.index+1;

		str = Template.string( str );
		token.text = str;
		token.types = ['StringTokn', 'ConstTokn'];
		token.location.end = b;
		return token;

	static regexp( ctx, src, text, i, token ):
		if !testValue( src, src.prevIndex( src.length, true ) ):
			if (b = indexRight(text, i, '/', '/')) === false:
				Err 'tokenize regexp pattern error! miss right token', token;
			if match = text.substr(b+1).match(/^[gimy]+/):
				b = b + match[0].length;
			token.text = Template.regexp( text.slice(i, b+1) );
			token.types = ['RegExpDecl', 'ConstTokn'];
			token.location.end = b;
		return token;

	static comm( ctx, src, text, i, token ):
		switch token.text:
			case '/*':
				if (b = indexRight(text, i, '/*', '*/')) === false:
					Err 'tokenize comment pattern error! miss right token', token;
				token.types = ['CommDecl', 'MultiLineComm'];

			case '//':
				token.types = ['CommDecl', 'LineComm'];

			case '#!':
				token.types = ['CommDecl', 'ShellComm'];
		if !b: 
			if (b = text.indexOf('\n', i)) == -1:
				b = text.length;
			b -= 1;

		token.text = text.slice(i, b+1);
		token.location.end = b;
		return token;

	static pound( ctx, src, text, i, token, cache):
		if match = text.substr(i+1).match(/^([\$A-Za-z_][\w\$]*)(\:?)/):
			type = match[1];
			if type in Processor:
				token = Processor[type]( ctx, src, text, i, token );

			else if /^(elifdef|elif|ifdef|else|endif|if)$/.test(type):
				token = Processor.control( ctx, src, text, i, token, type, cache );
			
			else if type == 'end':
				token = text.indexOf('\n', i);
			
			else:
				token.text = '#'+match[0];
				token.types = ['InstructionExpr', 'ConstTokn'];
				token.location.end = i+match[0].length;
				token = parseMacro( ctx, src, text, i, token, match[0], token.location.end );
		return token;

	static token( ctx, src, text, i, token ):
		if m = text.substr(i).match(/^#token (\w+(?:\s*,\s*\w+)*) (.*)$/m):
			var types = Text.split(m[1], ',', true),
				symbols = Text.split(m[2], ',', true);
			tea.defineToken( types, symbols );
			prep_log '[Prep define token: g{"'+symbols.join('","')+'"}]', token;
			return i + m[0].length;
		else:
			Err 'define token syntax error!', token;

	static line( ctx, src, text, i, token ):
		token.text = token.location.lineNumber+'';
		token.types = ['NumTokn', 'ConstTokn'];
		if token.indent >= 0:
			token.types.push('LineHead');
		token.location.end = i+4;
		return token;

	static argv( ctx, src, text, i, token ):
		if not m = text.substr(i).match(/^#argv (.*$)/m):
			Err 'define argv syntax error!', token;
		var args = Text.split(m[1], ' ', true);
		for item => args:
			if !item: continue;
			if arg = item.match( /\s*((-{0,2})[\w\-]+)(?:\s*=\s*(.*))?/ ):
				tea.argv[arg[1]] = evalValue(arg[3]);
				prep_log '[Prep set argv: g{'+arg[1]+' == '+tea.argv[arg[1]]+'}]', token;
		return i + m[0].length;

	static run( ctx, src, text, i, token ):
		if not abcd = indexInstruction(text, i):
			Err 'define run script syntax error', token;
		b = abcd[3];
		try:
			if res = Template.run( text.slice(i+4, b-3), ['source', 'index', 'argv'], [src, i, tea.argv], ctx):
				src.parse( res, null, ctx );
				prep_log '[Prep run instruction]', token;

		catch e:
			var err_pot = tea.helper.errorPot(token);
				err_pot = err_pot.replace(/[^\n]*$/g, '') + text.slice(i+4, b-3).replace(/^/mg, err_pot.match(/"(\s*\d+\s*\|)/)[1]+'\t')+'\n"';
			Err e, 'Prep run eval error: '+e.message, err_pot;
		return b + 1;

	static define( ctx, src, text, i, token ):
		if not m = text.substr(i).match(/^#define +
										(\w+)(\(.*?\))? *
										(\s*""""[\w\W]*?""""|(?:.*\\\n)*.*)/):
			Err 'define macro syntax error!', token;
		name   = m[1],
		params = m[2] && (m[2].slice(1, -1).trim() || []),
		body   = m[3] && Text.trimIndent( m[3].replace(/\\\n/g, '\n' ).replace(/^\s*""""|""""\s*$/g, ''));
		
		if body && /#(?:if|argv)/.test(body):
			body = ctx.parse(body).join();

		var macro = ctx.add(name, params, body);
		if macro.error:
			Err macro.error, token;
		prep_log '[Prep define: g{'+name+(m[2]||'')+'}]', token;
		return i + m[0].length;

	static undef( ctx, src, text, i, token ):
		if not m = text.substr(i).match(/^#undef (.+)$/m):
			Err 'undefine syntax error!', token;
		var names = m[1].trim().replace(/\s+/g, ' ').split(' ');
		for name => names:
			ctx.undef(name);
		prep_log '[Prep undef: g{'+names.join(', ')+'}]', token;
		return i + m[0].length;

	static include( ctx, src, text, i, token ):
		if not m = text.substr(i).match(/^#include +((?:[^\,\;\s\\]+(?:\\\ )*)+(?:\s*,\s*(?:[^\,\;\s\\]+(?:\\\ )*)+)*)\;*/):
			Err 'include syntax error!', token;
		file_list = m[1].replace(/\s*,\s*/g, ',').replace(/\s*;+/g, '').trim().split(','),
		file_dir  = Path.dirname( token.fileName || src.fileName );
		files     = [];
		for f -> file_list:
			temp = Path.parseFile(file_list[f], file_dir);
			if temp.error:
				Err 'Can not find file: '+file_list[f]+' in "'+file_dir+'" dir', token;
			for file => temp:
				if !include_cache[file]:
					include_cache[file] = ctx.parse( null, file );
					include_cache[file].trimIndent();
				if include_cache[file].length:
					src.insert( token.clone('/* Include file "'+file+'" */\n', ['CommDecl']) );
					src.insert( include_cache[file].clone() );
					prep_log '[Prep include: file at g{"'+file+'"}]', token;
		return i + m[0].length;

	static test( ctx, src, text, i, token ):
		if not b = indexRight(text, i, '#test', '#end'):
			b = text.length;
		text = text.slice(i, b-3);
		if not m = text.match(/#test(.*)\n/):
			Err 'define test block syntax error', token;
		text = text.substr(m[0].length);
		if m[1] && m[1].trim() == 'run':
			tea.argv['--test'] = true;
		token.text = '/* Test: */\n'+tea.compile(text, ctx)+'\n/* Test end */';
		token.types = ['TestPatt', 'CommDecl'];
		src.add( token );
		return b + 1;

	static expr( ctx, src, text, i, token ):
		if not m = text.substr(i).match(/#(expr|stat) +
										([A-Z][\w]+(?:Tokn|Patt|Decl|Expr|Stam)) +
										[\/\`]((?:[^\/\`]|\\\/|\\\`)+)[\/\`] *
										(\s*""""[\w\W]*?""""|(?:.*\\\n)*.+)/):
			Err 'define syntactic sugar syntax error', token;
		type    = m[1] == 'expr' ? 'expression' : 'statement';
		name    = m[2];
		pattern = m[3];
		writer  = Text.trimIndent( m[4].replace(/\\\n/g, '\n' ).replace(/^\s*""""|""""\s*$/g, '') );
		var ss = ctx.add( type, name, pattern, writer );
		if ss.error:
			Err ss.error, token;
		prep_log '[Prep register '+type+': '+name+' -> /'+pattern+'/]', token;
		return i + m[0].length;

	static control( ctx, src, text, i, token, type, cache ):
		if type == 'if' || type == 'ifdef':
			if not blocks = indexControl(text, i):
				Err 'define control preprocess syntax error', token;
			status = false;
			for item => blocks:
				if status:
					item[1] = false;
				else:
					item[1] = status = evalCondition( ctx, item[0], item[1], src, token );
				cache[ item[2] ] = item;

		if not data = cache[i]:
			Err 'unexpected #'+type+' ctx instruction', token;

		if data[1]:
			return data[4]+1;
		else:
			return data[5]+1;

	static macro( ctx, src, text, i, token ):
		if testIdExpr(src, src.length):
			return parseMacro(ctx, src, text, i, token, token.text);
		return token;

	static stam = @.expr;

	function parseMacro( ctx, src, text, i, token, name, b = i + name.length - 1 ):
		if macro = ctx.get(name, 'macrofun'):
			params = text.substr( b + 1 );
			if /^\s*\(/g.test(params) && ab = Text.indexPair(params, 0, '(', ')'):
				b += ab[1] + 1; 
				params = params.slice(ab[0]+1, ab[1]);
			else if /^\ +[^\n\;\}\]\)\,]/.test(params):
				ab = Text.indexBreak(params, 0);
				b += ab + 1;
				params = params.slice(0, ab+1);
			else:
				params = '';

		if !macro || !params:
			macro = ctx.get(name, 'macro');

		if macro:
			val_src = macro.getValue(params, true);
			if src:
				src.insert( val_src );
				prep_log '[Prep macro matched: '+name+']', token;
			else:
				return val_src.join();
			return b + 1;
		return token;
	function indexInstruction(text, i):
		if m = text.substr(i).match(/^#(\w+)(\:?)/):
			a = i, a_ = i + m[0].length - 1;
			b = i + m[0].length - 1;
			type = m[1];
			label = !!m[2];
			var t = 10;
			while t--:
				if not m = text.substr(b+1).match(/#(\w+)(\:?)/):
					b = text.length, b_ = b;
					break;
				else:
					if m[1] == 'end' || m[1] == 'end'+type || m[1] == 'endif' && /^(ifdef|if|elifdef|elif|else)$/.test(type):
						b = b + 1 + m.index, b_ = b + m[0].length - 1;
						break;
					else if label && m[2] || /^(elifdef|elif|else)$/.test(m[1]):
						b_ = b = b + m.index;
						break;
					b = b + m.index;
					if /^(ifdef|if)$/.test(m[1]):
						if not b = indexControl(text, b+1, 'end'):
							return;
					else if /^(run|test)$/.test(m[1]) || m[2] == ':':
						if not abcd = indexInstruction(text, b+1):
							return;
						b = abcd[3];
			return [a, b, a_, b_];
		else:
			Err 'not find instruction';
	function indexControl(text, i, only_index):
		re = /^#(ifdef|if)\b/;
		cache = [];
		while re.test( text.substr(i) ):
			if not abcd = indexInstruction(text, i):
				return;
			[a, b, _a, _b] = abcd;
			if only_index:
				cache.push( [a, b, _a, _b] );
			else:
				m = text.substr(_a+1).match(/.*$/m);
				cache.push( [text.slice(a+1, _a+1), m[0] , a, b, _a + m[0].length, _b] );
			re = /^#(elifdef|elif|else)\b/;
			i = _b + 1;

		if !only_index:
			var last = cache[-1];
			if m = text.substr(last[3]).match(/^#(endif|end).*$/m)://.test( text.slice(last[3], last[5]+1) ):
				cache.push( ['endif', '', last[3], last[3], last[5], last[3]+m[0].length-1])

		if only_index == 'end':
			return cache[-1][3]
		return cache;
	function indexRight(text, index, s1, s2 = s1):
		var a_b = Text.indexPair(text, index, s1, s2, true);
		return !a_b || a_b[0] !== index ? false : a_b[1]+s2.length-1;
	function testValue(src, index):
		if token = src[ index ]:
			if token.is('ConstTokn', 'Close', 'Postfix'):
				return true;
			if token.is('IdentifierTokn'):
				if !token.is('Binary', 'Unary'):
					return true;
			else if token.is('Keyword'):
				if token.is('Restricted'):
					return false;
			else:
				return false;
			token = src[ src.prevIndex( index, true ) ];
			if token && token.is('Member'):
				return true;
		return false;
	function testIdExpr(src, index):
		last = src[ src.prevIndex(index, true) ];
		if last && last.eq('.', '::', '..', 'function', 'set', 'get', 'static'):
			return false;
		return true;
	function evalValue(val):
		if val == 'false' || val == 'null':
			return false;
		else if val:
			try:
				return eval( val );
			catch e:
				return '"'+val+'"';
		return true;
	function evalCondition(ctx, type, condition, src, token):
		isdef     = type.indexOf('def') != -1,
		root_file = tea.argv.file,
		the_file  = token.fileName || src.fileName,
		exp       = condition.trim().replace(/\:$/, '').replace(/((-{0,2})([\$a-zA-Z_][\w]*)\b)/g,
						function($0, $1, $2, $3):
							var res;
							if $2:
								if $3 == 'main':
									return root_file == the_file;
								if $3 == 'root':
									return '"'+root_file+'"';
								if $3 == 'file':
									return '"'+the_file+'"';
								res = tea.argv[$1];
							else if isdef:
								return !!ctx.get( $1 )+'';
							else:
								if $1 in global:
									res = global[$1];
								else if $1 in tea.argv:
									res = tea.argv[$1];
								else:
									return $1;
							return typeof res == 'string' ? '"'+res.replace(/\"/g, '\\"')+'"' : res;
		);
		try:
			return exp && eval('!!('+exp+')') || type == 'else';
		catch e:
			Err e, '[ProProcess condition '+type+' "'+condition+'" -> "'+exp+'" error', token, 'ProProcess condition error!';

module.exports = Processor;