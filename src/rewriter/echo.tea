
function toText(write, comma_mark):
	var texts = [], text;
	for i, item -> write:
		if !item:
			continue;

		if item == ',':
			texts.push(',\0');
			continue;

		if item as 'string' || item as 'number':
			texts.push(item);
			continue;

		if item.istoken:
			texts.push(item.text);
			continue;

		if !item.iswriter:
			Err 'bad writer data!!'+isClass(item);

		switch item.type:
			case 'VarDecl', 'LetDecl':
				[text, i] = concatVarDecl(write, i);
			default:
				text = toText(item);

		text = beautify(item.type, text, write.type);
		if !comma_mark:
			text = text.replace(/,\0/g, ', ');
		texts.push( text );

	return texts.join('');

function concatVarDecl(parent, index):
	str = toText( parent[index], true );
	while true:
		_i = index+1;
		while parent[_i] as 'string' && /^[;|\n|\s]+$/.test(parent[_i]):
			_i += 1;
		if parent[_i] && /LetDecl|VarDecl/.test(parent[_i].type):
			str += ',\0'+toText( parent[_i], true).replace(/^var\s*/, '');
			index = _i;
			continue;
		break;
	return [str, index];

function beautify(type, text, parent_type):
	switch type:
		case 'NodeStam':
			if parent_type != 'Root' && text:
				text = '\n\t'+text.replace(/^/mg, '\t').trim()+'\n';

		case 'JsonExpr', 'ArrayExpr', 'VarDecl':
			if text.length > 80 || /\n/.test(text):
				text = text.replace(/,\0/g, ',\n').replace(/^/mg, '\t').trim();
	return text;

exports.toText = toText;