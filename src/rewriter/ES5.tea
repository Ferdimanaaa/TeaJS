
var ES5 = {
'CommaExpr CommaStam ArgumentsDecl'                     : 'COMMA(#)',
'ArgumentsExpr CompelExpr ConditionStam'                : '\(COMMA(#)\)',
'ParamsStam ParamsExpr'                                 : '\(ParamsPatt(#)\)',
'ArrayExpr'                                             : '\[COMMA(#)\]',
'JsonExpr'                                              : '\{COMMA(#)\}',
'PrefixExpr PostfixExpr'                                : '#0#1',
'ReturnStam BreakStam ContinueStam ThrowStam'           : '#0 #1',
'DotExpr'                                               : '.#0',
'DebuggerStam'                                          : '#0',
'FunctionDecl'                                          : '#0 #1#2#3',
'FunctionExpr'                                          : '#0#1#2',
'ExportDecl'                                            : '#1',
'IfPatt'                                                : '#0 #1#2',
'ElseIfPatt'                                            : '#0 if #1#2',
'ElsePatt'                                              : '#0 #1',
'WhileStam'                                             : '#0 #1#2',
'WithStam'                                              : '#0 #1#2',
'TryPatt'                                               : '#0 #1',
'CatchPatt'                                             : '#0 #1 #2',
'FinallyPatt'                                           : '#0 #1',
'ThisExpr'                                              : 'this#1',
'LabelStam'                                             : '#0#1 #2',
'ForBaseConditionPatt'                                  : '(#0; #1; #2)',
'ForInConditionPatt'                                    : '(#0 #1 #2)',
'UnaryExpr'                                             : '(? #0 eq +) Math.abs(#1) | (? #0 is SymbolTokn) #0#1 | #0 #1',
'NotExpr'                                               : '(? #1 is ValueExpr) !#0 | !(#1)',
'TernaryExpr'                                           : '(? #2 is ExprStam && #4 is ExprStam) #0 #1 #2 #3 #4 | if (#0) #2; else #4',
'LambdaExpr'                                            : '(? #1 is ReturnStam) function#0{#1} | function#0{return #1}',
'Root'                                                  : 'NodeStam(#0)',
'BlockStam IndentBlockStam LineBlockStam StamBlockStam' : '{NodeStam(#)}'
};

ES5.TestPatt = function(node, __write):
	if tea.argv['--test']:
		__write.add( node );

ES5.CommDecl = function(node, __write):
	if !tea.argv['--clear'] || node.text[0] == '#':
		__write.add( node );

ES5.IdentifierExpr = function(node, __write):
	var id = node[0],
		scope = node.scope;
	if let_name = scope.getLet( id.text ):
		id.text = let_name;
	else if @.class_scope:
		switch scope.isDefined(id.text):
			case 'static', 'unknow':
				if @.class_scope.variables[id.text] == 'static':
					id.text = @.class_scope.name+'.'+id.text;
	__write.read( id );

ES5.ComputeExpr = function (node, __write):
	var list = [];
	for i -> node:
		switch node[i].istoken && node[i].text:
			case '**':
				list.push( 'Math.pow(', list.pop(), ', ', node[++i], ')' );
			case '\\':
				list.push( 'Math.floor(', list.pop(), '/', node[++i], ')' );
			default:
				list.push( node[i] );
	__write.read(list);

ES5.CompareExpr = function (node, __write):
	var list = [];
	if node.length == 5 && node[3].eq('<', '>', '>=', '<='):
		return '#0 #1 #2 && #2 #3 #4';

	for i -> node:
		switch i%2 && node[i].text:
			case 'as':
				if node[i+1].type == 'StringTokn':
					list.push( 'typeof ', list.pop(), ' == ', node[++i] );
				else:
					list.push( ' instanceof ', node[++i] );
			case 'in':
				if node[i+1].type == 'ArrayExpr':
					list.push( node[++i], '.indexOf(', list.pop(), ')>=0');
				else:
					list.push( node[++i], '.hasOwnProperty(', list.pop(), ')');
			case 'of':
				list.push( '[].indexOf.call(', node[++i], ', ', list.pop(), ')>=0');
			case 'is':
				node[i].text = ' === ';
				list.push(node[i]);
			case 'not is':
				node[i].text = ' !== ';
				list.push(node[i]);
			default:
				if i%2:
					node[i].text = ' '+node[i].text+' ';
				list.push( node[i] );
	__write.read( list );

ES5.LogicExpr = function (node, __write):
	for i=1; i < node.length; i+=2:
		switch node[i].text:
			case 'and':
				node[i].text = '&&';
			case 'or':
				node[i].text = '||';
	if node.length == 3:
		if node[2].is('ExprStam'):
			return '#0 #1 #2';
		if node.parent.is('NodeStam'):
			if node[1].text == '||':
				if node[0].is('ValueExpr'):
					return 'if (!#0) #2';
				return 'if (!(#0)) #2';
			return 'if (#0) #2';
		return '#0 #1 (#2)';
	__write.read( @.JOIN(Hash.slice(node), ' ') );

ES5['Ternary2.5Expr'] = function(node, __write):
	if node.parent.is('NodeStam'):
		return 'if (#0) #2';
	else:
		if !node[0].is('ValueExpr'):
			var ref = allocateRefName(node.scope);
			return '(('+ref+' = #0) != null ? '+ref+' : #2)';
	return '(#0 != null ? #0 : #2)';

ES5.SeleteStam = function (node, __write):
	switch node[1].text:
		case 'if', '<-':
			return 'if (#2) #0';
		case 'or', '||':
			if node[0].is('ValueExpr'):
				return 'if (!#0) #2';
			return 'if (!(#0)) #2';
		default:
			return 'if (#0) #2';

ES5.AssignmentExpr = function(node, __write):
	var left = node[0], right = node[2];
	if left.type == 'ArrayPatt':
		return assignmentArrayPatt.call(@, __write, left, right, node);

	else if left.type == 'AccessorPatt' && left[-1].type == 'SlicePatt':
		return assignmentSlicePatt.call(@, __write, left, right, node)

	else if node.parent.type == 'ArgumentsExpr':
		return left;
	else:
		switch node[1].text:
			case '?=':
				if node.parent && node.parent.is('NodeStam'):
					return 'if (#0 == null) #0 = #2';
				return '(#0 == null && (#0 = #2))'
			case '|=':
				if node.parent && node.parent.is('NodeStam'):
					return 'if (!#0) #0 = #2';
				return '(!#0 && (#0 = #2))'
	if node.parent.type == 'JsonExpr':
		if node[0].is('IdentifierTokn')
			return '"#0"#1 #2';
	return '#0 #1 #2';

ES5.AssignmentDecl = ES5.AssignmentExpr;

ES5.ParamsPatt = function(node, __write):
	for i, item -> node:
		if item.istoken && item.text == ',':
			__write.add('null');
		else:
			__write.read( item );
	@.COMMA( __write );

ES5.SlicePatt = function(node, __write):
	var ab = accessorSlicePatt.call(@, node);
	if !ab[1]:
		__write.read( '.slice(', ab[0]||'', ')' );
	else:
		__write.read( '.slice(', ab[0]||'0', ', ', ab[1], ')' );

ES5.MemberExpr = function(node, __write):
	if node[0].type == 'UnaryExpr' && node[0][0].text == '-':
		var parent = node.parent.clone();
		parent.length = node.index;
		if parent:
			__write.read( '[#0.length#1]', [parent, node[0]] );
	else:
		__write.read('[', node[0], ']');

ES5.MemberPatt = function(node, __write):
	switch node[0].text:
		case '::':
			node[0].text = '.prototype';
		case '..':
			node[0].text = '.constructor';
	return '#0.#1';

ES5.LetDecl = function(node, __write):
	node[0].text = 'var';
	resetDefineVariableDecl(node[1], node.scope, 'let', 'let_');
	return '#0 #1';

ES5.VarDecl = function(node, __write):
	resetDefineVariableDecl(node[1], node.scope, 'defined');
	return '#0 #1';

ES5.DoWhileStam = function(node, __write):
	if node[2]:
		return '#0 #1 #2 #3';
	else:
		return '#0{NodeStam(#1)break;} while (true)';

ES5.TryStam = function(node, __write):
	if node.length > 1:
		return '#';
	else:
		return '# catch (_e){}';

ES5.SwitchStam = function(node, __write):
	var block = node[2],
		block_body = @.new('NodeStam'),
		exp_cache = [], case_write, sub_block;

	for item => block:
		case_write |= @.new(item.type);
		if item.type == 'CaseStam':
			for key => item[1]:
				case_write.read( item[0], ' ', key, ':' );
			sub_block = item[3];
		else:
			case_write.read( item[0], ':' );
			sub_block = item[2];

		if sub_block:
			var sub_write = ES5.SwitchCaseBlock.call(@, sub_block, @.new('NodeStam') );
			block_body.read( case_write.read(sub_write) );
			case_write = null, sub_block = null;

	__write.read( node[0],' ', node[1], @.new(block.type, '{', block_body, '}') );

ES5.SwitchCaseBlock = function (node, __write):
	var last = node.length - 1;
	while node[last] && node[last].is('CommDecl'):
		last -= 1;
	
	var insert_break = true;
	if node[last] && node[last].is('ReturnStam', 'BreakStam', 'ContinueStam'):
		if node[last].type == 'ContinueStam':
			node[last] = null;
		insert_break = false;

	ES5.NodeStam.call(@, node, __write );
	if insert_break:
		__write.read( '\nbreak;' );
	return __write;

ES5.forCondition = function(node, __write):
	var scope = node.scope;
	var exp1 = node[0], exp2 = node[1], exp3 = node[2];
	var $mark = exp2 && exp2.text || '->', $var, $i, $i_text, $def, $temp, $len, $tar, $tar_exp;

	if exp1.type == 'VarDecl':
		$var = true, exp1 = exp1[1];
		
	if !exp3:
		exp3 = exp1, exp1 = null;

	if exp1:
		switch exp1.type:
			case 'CommaExpr', 'ArgumentsDecl':
				$i = exp1[0], $temp = exp1[1];
			default:
				$i = exp1;
	if $i:
		if $i.type == 'AssignmentDecl' || $i.type == 'AssignmentExpr':
			$def = $i[2], $i = $i[0];
		else if $i.type == 'ConstTokn':
			$def = $i, $i = null
		if $i:
			if $i.type == 'IdentifierExpr':
				$i = $i[0];
			if $i.type != 'IdentifierTokn':
				tea.throw 'for condition(3) statiment syntax error!', $i;
			if /\=|of/.test($mark):
				$temp = $i, $i = null;
	if !$i:
		$var = true, $i = allocateVarName(scope);
	
	$i_text = $i.text || $i;

	var def_type = scope.isDefined($i_text);
	$var = $var || !def_type || def_type == 'let';

	if exp3.type =='CommaExpr' && exp3.length == 1:
		exp3 = exp3[0]

	switch exp3.is('ArrayExpr', 'JsonExpr', 'AccessorExpr', 'IdentifierExpr', 'AtExpr', 'NumTokn'):
		case 'AccessorExpr', 'IdentifierExpr', 'AtExpr':
			$tar = exp3;
		case 'NumTokn':
			$len = @.new('NumTokn').read(exp3);
		default:
			$tar = $i_text+'_ref';
			$tar_exp = @.new('AssignmentExpr').read( $tar, ' = ', exp3);

	$len = $len || @.new('AssignmentExpr').read($tar, '.length');
	$tar = @.new('IdentifierExpr').read($tar);
	$i = @.new('IdentifierExpr').read($i);
	return [$mark, $var, $i, $def, $temp, $len, $tar, $tar_exp];

ES5.ForStam = function(node, __write):
	var condition = node[1];
	if condition.type == 'ForBaseConditionPatt':
		// condition.type == 'ForInConditionPatt':
		return '#0 #1#2';

	var scope = node.scope;
	var [$mark, $var, $i, $def, $temp, $len, $tar, $tar_exp] = ES5.forCondition.call(@, condition);

	scope.setLet('__length', $len.text );
	scope.setLet('__index',  $i.text );
	scope.setLet('__target', $tar.text );

	var cond_body  = @.new('ConditionBody');
		block_body = @.new('NodeStam');

	if /in|of/.test($mark):
		cond_body.read( $var ? 'var ':'', $i, ' in ', $tar );
		if $tar_exp:
			__write.read( @.VAR( $tar_exp ), ';\n' );
		block_body.add( @.new('IfStam', 'if (!#0.hasOwnProperty(#1)) continue;\n', [$tar, $i]) );
		if $temp:
			block_body.add( @.new('AssignmentExpr', 'var #0 = #1[#2];\n', [$temp, $tar, $i]) );
	else:
		if $mark[0] == '<':
			if $def = $def || [$tar, '.length-1']:
				$def = [$i, '=', $def];
			cond_body.read('#0; #1 >= #2; #1--', [@.VAR($tar_exp, $def, $temp), $i, '0'] );
		else:
			if $def = $def || $var && '0':
				$def = [$i, '=', $def];
			cond_body.read('#0; #1 < #2; #1++', [@.VAR($tar_exp, $def, $temp), $i, $len] );

		if $temp:
			block_body.add( @.new('AssignmentExpr', '#0 = #1[#2];\n', [$temp, $tar, $i]) );
	
	ES5.NodeStam.call(@, node[2], block_body);
	__write.add(node[0], ' ', @.new('ForConditionPatt', '(', cond_body, ')'), @.new(node[2].type, '{', block_body, '}'));

ES5.PackageExpr = function(node, __write):
	if node.length == 2:
		return '(function()#1)()';

	var params = @.new('ParamsExpr'),
		argus = @.new('ArgumentsExpr'),
		has_ass = false;
	if node[1].length:
		resetDefineVariableDecl(node[1], node.scope, 'argument');
		for i, item -> node[1]:
			if item.type == 'AssignmentDecl':
				has_ass = true;
				argus.read( item[0] );
				params.read( item[2] );
			else:
				argus.read( '_'+i );
				params.read( item );

	__write.read( '(function(#0)#1)(#2)', [@.COMMA(argus), node[2], @.COMMA(params)]);

/*******************************************/
ES5.ClassExpr = function(node, __write):
	var _i = 1, scope = node.scope, name, extend, block, is_ass = false;
	if node[_i].type == 'IdentifierTokn':
		name = node[_i++];
	if node[_i].type == 'ExtendsExpr':
		extend = node[_i++];
	if !name:
		if node.parent.type == 'AssignmentDecl':
			is_ass = true;
			name = node.parent[0];
		else if node.parent.type == 'AssignmentExpr':
			is_ass = true;
			name = node.parent[0][0];
	if !name:
		Err 321, node[0];

	scope.name = name.text;
	block = node[_i];

	var old_scope = @.class_scope;

	@.class_scope = scope;

	var block_write = @.new('NodeStam');
	ES5.NodeStam.call(@, block, block_write);

	_i = 0;
	for _i -> block_write:
		if block_write[_i].type:
			if /VarDecl|LetDecl|Assignment|Require/.test(block_write[_i].type):
				continue;
		else if block_write[_i] as 'string' && /\s*(\n|;|,)\s*/.test(block_write[_i]):
			continue;
		break;

	if extend:
		block_write.insert(_i, ES5.ExtendsExpr.call(@, extend));

	var construct_write = @.new('ConstructorStam'),
		construct_body = @.new('NodeStam');
	if scope.inits.length:
		construct_body.read(scope.inits);
	if scope.construct:
		ES5.NodeStam.call(@, scope.construct[2], construct_body);
		construct_write.read('function #0#1{#2}\n', [name, scope.construct[1], construct_body]);
	else:
		construct_write.read('function #0(){#1}\n', [name, construct_body]);

	block_write.insert(_i, construct_write);

	block_write.read('\nreturn #0;', [name]);
	if is_ass:
		__write.read('(function(){#0})()', [block_write]);
	else:
		__write.read('var #1 = (function(){#0})()', [block_write, name]);

	@.class_scope = old_scope;

ES5.ExtendsExpr = function(node, __write):
	__write |= @.new('ExtendsExpr');
	var scope = node.scope,
		name  = scope.name,
		list  = node[1];

	__write.read('
		#0.prototype = new #1();
		#0.prototype.constructor = #0;
		#0.prototype.__super__ = #1.prototype;\n
		', [name, list[0]] );
	if list.length > 1:
		__write.read('
			#0.__extends = function(){
				for (var i=0; i<arguments.length; i++){
					var _super = arguments[i].prototype;
					for (var name in _super)
						if (_super[name].hasOwnProperty(name))
							this.prototype[name] = _super[name];
				}
			};
			#0.__extends(COMMA(#1));\n
			', [name, Hash.slice(list, 1)]);
	return __write;

ES5.SuperExpr = function(node, __write):
	var acc = node[0], pam = node[1], supe = acc[0];
	supe.text = 'this.__super__';
	if acc.length == 1:
		supe.text += '.'+(node.scope.name||'constructor');
	if pam:
		var pam_write = @.read(pam);
		pam_write[1].insert(0, 'this', ', ');
		__write.read(acc, '.call', pam_write);
	else:
		return '#0.call(this, arguments)';

ES5.AtExpr = function(node, __write):
	var scope = node.scope;
	if scope.type == 'ClassExpr':
		node[0].text = scope.name;
	else:
		scope = scope.queryParent('ClassExpr');
		if scope && classStaticAtSymbol(scope, node):
			node[0].text = scope.name;
		else:
			node[0].text = 'this';
	return '#';

ES5.SetterDecl = function(node, __write):
	if node.parent.type == 'JsonExpr':
		return '#0 #1#2#3';
	var class_scope = node.scope.parent;
	if class_scope.type == 'ClassExpr':
		var type = node.type=='SetterDecl' ? '__defineSetter__' : '__defineGetter__';
		if node.length < 4:
			__write.read('#0.prototype.'+type+'("#1", function()#2)', [class_scope.name, node[1], node[2]]);
		else:
			__write.read('#0.prototype.'+type+'("#1", function#2#3)', [class_scope.name, node[1], node[2], node[3]]);

ES5.GetterDecl = ES5.SetterDecl;

ES5.MethodDecl = function(node, __write):
	if node.parent.type == 'JsonExpr':
		return '"#0": function#1#2';
	var scope = node.scope,
		class_scope = scope.parent;
	switch class_scope.type:
		case 'ClassExpr':
			var class_name = class_scope.name;
			if scope.name == 'constructor':
				class_scope.construct = node;
				return '';
			else:
				__write.read('#0.prototype.#1 = function #2#3', [class_name, node[0], node[1], node[2]]);
		default:
			return 'function #0#1#2';

ES5.StaticDecl = function(node, __write):
	var class_scope = node.scope;
	if class_scope.type != 'ClassExpr':
		class_scope = class_scope.parent;
	var exp = node[1];
	if exp.type == 'ArgumentsDecl':
		for i, item -> exp:
			if item.type == 'AssignmentDecl': 
				__write.read('#0.#1 #2 #3;', [class_scope.name, item[0], item[1], item[2]]);
			else:
				__write.read('#0.#1 = null;', [class_scope.name, item]);
			if i < exp.length - 1:
				__write.add('\n');
	else:
		__write.read('#0.#1 = function#2#3;', [class_scope.name, exp[0], exp[1], exp[2]]);

ES5.ProtoDecl = function(node, __write):
	var class_scope = node.scope.queryParent('ClassExpr');
	if !class_scope:
		Err 325, node[0];
	var exp = node[1],
		class_name = class_scope.name;
	if exp.type == 'ArgumentsDecl':
		for i, item -> exp:
			if item.type == 'AssignmentDecl': 
				__write.read('#0.prototype.#1 #2 #3;', [class_name, item[0], item[1], item[2]]);
			else:
				__write.read('#0.prototype.#1 = null;', [class_name, item]);
			if i < exp.length - 1:
				__write.add('\n');
	else:
		__write.read('#0.prototype.#1 = function#2#3;', [class_name, exp[0], exp[1], exp[2]]);

ES5.InitDecl = function(node, __write):
	var class_scope = node.scope;
	if class_scope.type != 'ClassExpr':
		Err 326, node[0];
	var exp = node[1],
		write = @.new('InitDecl');
	if exp.type == 'ArgumentsDecl':
		for i, item -> exp:
			if item.type == 'AssignmentDecl': 
				write.read('this.#0 #1 #2;\n', item);
			else:
				write.read('this.# = null;\n', item);
	else:
		write.read('this.#0 = function#1#2;\n', exp);
	class_scope.inits.push(write);
	return '';

/*******************************************/

ES5.RequireStam = function(node, __write):
	var scope = tea.argv['--join'] ? node.scope.root : 0,
		params = parseRequire(node[1], scope);

	if params.length > 1:
		if node.parent.is('AssignmentDecl', 'AssignmentExpr'):
			if node.parent[0].type == 'ArrayExpr':
				format = '#0(#1)';
				type = 'arr';
				write = @.new('ArrayExpr');
			else:
				format = '"#2": #0(#1)';
				type = 'json';
				write = @.new('JsonExpr');
		else:
			format = 'var #2 = #0(#1)';
			type = 'var';
			write = @.new('VarExpr');
	else:
		write = __write;
		format = '#0(#1)';

	for i -> params:
		_format = params[i].name ? format : '#0(#1)';
		write.read( @.new('RequireExpr', _format, [node[0], params[i].expr, params[i].name]) );
	
	switch type:
		case 'var':
			__write.read( @.JOIN(write, ';\n') );
		case 'json':
			__write.read( '{', @.JOIN(write, ', '), '}' );
		case 'arr':
			__write.read( '[', @.JOIN(write, ', '), ']' );

ES5.NodeStam = function (node, __write):
	__write |= @.new('NodeStam');
	var len = node.length - 1;
	for i, item -> node:
		res = @.read(item);
		if res && (res.istoken || res.length):
			__write.add( res );
			if item.type != 'CommDecl' && (item.is('AssignmentExpr','ClausesStam', 'CommaStam') || ! /(\}|;)$/.test(res.lastText) ):
				__write.add(';');
			if i < len:
				__write.add('\n');

	nodeVarSafety.call(@, node, __write);
	return __write;

function nodeVarSafety(node, __write):
	var argv = tea.argv || {};
	var scope = node.scope;
	var a = 0;
	while __write[a] && (__write[a].type == 'CommDecl' || __write[a] == '\n'):
		a += 1;

	if !argv['--safe']:
		var un_defineds = scope.get('undefined');
		if un_defineds && un_defineds.length:
			__write.insert(a, @.VAR.apply(@, un_defineds), ';\n');

	var argus = scope.argumentsDefine;
	if argus && argus.length:
		var write = @.new('ArgumentsStam');
		for i -> argus:
			write.read( 'if (#0 == null) #0 #1 #2;\n', argus[i] );
		__write.insert(0, write);

	var exts = scope.exports;
	if exts && exts.length:
		var write = @.new('ExportStam');
		for i -> exts:
			write.add('\nmodule.exports.'+exts[i]+' = '+exts[i]+';');
		__write.add(write);

	// if !node.parent.is('ScopeNode'):
	// 	var lets = scope.get('let');
	// 	if lets && lets.length:		
	// 		for i in lets:
	// 			lets[i] = scope.lets[lets[i]] || lets[i];
	// 		var write = @.new('DeleteLetStam').read(lets, 'undefined');
	// 		__write.read('\n', @.JOIN(write, ' = '), ';');

function assignmentSlicePatt(__write, left, right, node):
	left.length -= 1;
	if left[left.length].length == 0:
		__write.read( '#0.push(#1)', [left, right] );
	else:
		var ab = accessorSlicePatt.call(@, left[left.length], true );
		__write.read( '#0.splice.apply(#0, [#1, #2].concat(#3))', [left, ab[0], ab[1], right] );
	
function assignmentArrayPatt(__write, left, right, node):
	if right.type == 'ArrayExpr':
		for i -> left:
			if i > 0:
				__write.add(', ')
			if right[i]:
				__write.read( '#0 #1 #2', [left[i], node[1], right[i]] );
			else:
				Err 'array pattern assignment declaration syntax error', right[ i-1 ];
	else:
		if right.is('IdentifierExpr'):
			ref = right;
		else:
			var ref = allocateRefName( node.scope );
			if node.parent.parent.type == 'VarDecl':
				node.scope.set('defined', ref, true);
			__write.read( @.new('AssignmentExpr', '#0 = #1', [ref, right]) );
		for i -> left:
			__write.read( @.new('AssignmentExpr', '#0 #1 #2[#3]', [left[i], node[1], ref, i+'']) );
		@.COMMA(__write);

function accessorSlicePatt(node, count_b):
	var a, b 
	if node.length == 3:
		a = node[0], b = node[2];
	else if node.length == 2:
		if node[0].text == ':':
			a = 0, b = node[1];
		else:
			a = node[0], b = 0;
	else if node.length >= 1:
		a = 0, b = 0;

	if count_b:
		var parent = node.parent;
		var write = @.new('AccessorExpr');
		if b:
			write.type = 'ComputeExpr';
			if b[0] && b[0].text == '-':
				write.read( parent, '.length', b);
			else:
				write.read( b, '-', a);
			b = write;
		else:
			b = write.read(parent, '.length');
	return [a, b];

function resetDefineVariableDecl(decl_list, scope, type, prefix):
	for i, left -> decl_list:
		if left.type == 'AssignmentDecl':
			left = left[0];
		if left.type == 'ArrayPatt':
			for item => left:
				item.text = resetDefine(scope, type, item.text, prefix);
		else if left.istoken:
			left.text = resetDefine(scope, type, left.text, prefix);
		else:
			decl_list[i] = resetDefine(scope, type, decl_list[i], prefix);

function resetDefine(scope, type, name, prefix):
	scope.set(type, name, true);
	if prefix:
		if type == 'let':
			scope.lets[name] = prefix+name;
		return prefix+name;
	return name;

function allocateVarName(scope):
	var keymap = 'ijklmnopqrstuvwxyz';
	for i -> keymap:
		if !scope.isDefined('_'+keymap[i]):
			var key = '_'+keymap[i];
			scope.set('let', key);
			return key;
	return '__i';

function allocateRefName(scope):
	var i = 0, name = '_ref', stat = scope.isDefined(name, null, 1);
	while true:
		if !stat || stat == 'let':
			scope.set('undefined', name);
			return name;
		name += i++;
		stat = scope.isDefined(name, null, 1);

function classStaticAtSymbol(clas_scope, node):
	if clas_scope.type = 'ClassExpr':
		if node.length > 1 && node[1].type == 'DotExpr':
			var member = node[1][0];
			if member.type == 'IdentifierTokn' && clas_scope.statics.indexOf(member.text) != -1:
				var name = member.text;
				if clas_scope.protos.indexOf(name) == -1:
					return name;
	return false;

function parseRequire(node, scope):
	var list = [], root_dir  = node.root.filePath || '';
	for i, item -> node:
		if item.is('StringTokn'):
			if scope && Path.isPathText(item.text):
				var files = Path.parseFile(item.text, root_dir, ['.js', '.tea']);
				if !files.error:
					for file => files:
						list.push( {name:parseRequireName(file), expr: item.clone('"'+scope.addRequire(file)+'"'), file:file} );
					continue;
				tea_log '** [Require: Can not join file: '+item.text+']';
			list.push( {name:parseRequireName(item.text), expr: item, file:''} );
		else:
			list.push( {name:'', expr: item, file:''} );
	return list;

function parseRequireName(file):
	return Text.getName(file);

module.exports = ES5;