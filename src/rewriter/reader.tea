
class Reader:
	require "./writer.js", "./ES5.js";
	var pattern_cache = {};

	constructor( ctx ):
		if @.constructor != Reader:
			return new Reader(ctx);
		@.context = ctx;

	new (type):
		var write = new Writer(@, type);
		if arguments.length > 1:
			write.read.apply(write, Hash.slice(arguments, 1));
		return write;

	read (node, do_each):

		if !node:
			return;
		if !node.istoken && !node.isnode:
			return node;

		if !do_each && res = getReader( node.type, @, node ):
			if res.isnode:
				return @.read(res, true);
			return res;

		else if node.isnode:
			var write = @.new( node.type );
			for i, item -> node:
				write.read( item );
			return write;

		else if node.istoken:
			return node;

	patt (patt, node, write):
		if not patt = getPattern(patt, node):
			return;
		write |= @.new( patt.name || node.type );
		var patt_list = patt.list;
		for i, chip -> patt_list:
			if chip.ispattern:
				if res = parsePatternAccessor.call(@, chip, node):
					if res.type == write.type:
						for j -> res:
							write.read(res[j]);
					else:
						write.read(res);
				else if res === null && patt_list[ i-1 ] as 'string':
					Array.prototype.pop.call(write);
			else if chip:
				write.read( chip );
		return write;

	static compilePattern(source):
		if pattern_cache[source]:
			return pattern_cache[source];
		var chips = source.replace(/ ?\| ?/g, '|').split('|'),
			patt = [];
		for i, chip -> chips:
			var ptn = {condition:'', list:[], name:'', source:chip};
			if m = chip.match(/^\(\:(\w+)\)\ ?/):
				ptn.name = m[1];
				chip = chip.substr(m[0].length);
			if m = chip.match(/^\(\?(.*?)\)\ ?/):
				ptn.condition = compilePatternCondition(m[1]);
				chip = chip.substr(m[0].length);

			while m = chip.match(/\b([A-Z]\w+[A-Z]\w+)\(#(\d+(?:\.\d+)*)?\)|#(\d+(?:\.\d+)*)?/):
				ptn.list.push(chip.slice(0, m.index));
				ptn.list.push( compilePatternAccessor(m, ptn.source) );
				chip = chip.substr( m.index + m[0].length );
			if chip:
				ptn.list.push(chip);
			patt.push(ptn);
		patt.isreader = true;
		return pattern_cache[source] = patt;

	function getReader(type, self, node):
		var reader
		// if tea.argv['--ES'] == 6:
		// 	if type in ES6:
		// 		reader = ES6[type];

		if !reader && type in ES5:
			reader = ES5[type];

		if reader:
			if reader as 'function':
				write = self.new(type);
				reader = reader.call(self, node, write) || write;
			if reader as 'string' || reader.isreader:
				return self.patt(reader, node);
			return reader;

		if self.context && (reader = self.context.get(type, 'statement', 'expression')):
			return reader.read(self, node);

	function getPattern(patt, node):
		var patt = patt.isreader ? patt : Reader.compilePattern(patt);
		for i -> patt:
			if !patt[i].condition:
				return patt[i];
			var conds = patt[i].condition;
			
			for j, cond -> conds:
				item = getNodeItem(node, cond.indexs, true);
				if item && item[cond.fn].apply(item, cond.param):
					if cond.logic != '&&':
						return patt[i];
				else if cond.logic != '||':
					break;

	function getNodeItem(node, indexs, strict):
		var item = node;
		if indexs:
			for i => indexs:
				if item[i]:
					item = item[i];
				else:
					if strict:
						return null;
					break;
			if item == node || !item:
				return null;
		return item;

	function initReader(reader):
		for name, ptn in reader:
			if ptn as 'string':
				Reader.compilePattern(ptn);
			if / /.test(name):
				delete reader[name];
				for n => name.split(' '):
					reader[n] = ptn;

	function compilePatternCondition(text):
		var list = [];
		while m = text.match(/^\ *#(\d+(?:\.\d+)*)? (is|eq) (.*?)(\&\&|\|\||$)/):
			list.push( {fn:m[2], indexs:m[1]&&m[1].split('.'), param:m[3].trim().split(','), logic:m[4]});
			if m[4]:
				text = text.substr(m[0].length);
				continue;
			break;
		return list;

	function compilePatternAccessor(match, source):
		var fn, index, param;
		if fn = match[1]:
			index = match[2];
		else:
			index = match[3];
		if index:
			index = index.split('.');
		return {fn: fn, indexs: index, param: param, ispattern:true, source:source};

	function parsePatternAccessor(patt, node):
		if not item = getNodeItem(node, patt.indexs):
			return null;

		if !patt.fn:
			write = item.istoken || item.isnode ? @.read(item, node == item) : item;

		else if /^[A-Z]+$/.test(patt.fn) && @[patt.fn]:
			write = item.isnode || item.istoken ? @.read(item, node == item) : item;
			@[patt.fn](write);

		else if write = getReader(patt.fn, @, item):
			return write;
		else:
			Err 'writer patt has undefined function', [patt.source, -1, patt.fn];
		return write;

	initReader( ES5 );

	COMMA(write):
		return @.JOIN(write, ',');

	JOIN(write, separator):
		separator ?= ' ';
		for var i = write.length-1; i >=1; i--:
			Array.prototype.splice.call(write, i, 0, separator);
		return write;

	VAR():
		var list = [];
		for i -> arguments:
			if arguments[i]:
				list.push( @.read(arguments[i]) );

		if list.length:
			@.COMMA(list);
			var write = @.new('VarDecl', 'var #0', [list]);
			return write;

module.exports = Reader;
