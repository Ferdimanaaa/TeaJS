var Writer = require "./writer.js";
class Reader:
	var pattern_cache = {};
	var pattern_map  =  {};

	constructor( preprocessor ):
		if @.constructor != Reader:
			return new Reader(preprocessor);
		@.preProcessor = preprocessor;

	new (type):
		var write = new Writer(@, type);
		if arguments.length > 1:
			write.read.apply(write, Hash.slice(arguments, 1));
		return write;

	read (node, do_each):

		if !node:
			return;
		if !node.istoken && !node.isnode:
			return node;

		var res;
		if !do_each && node.type in pattern_map:

			res = pattern_map[node.type];

		else if !do_each && node.type in Reader.prototype:
			var write = @.new(node.type);
			var res = @[node.type](node, write ) || write;

		else if !do_each && @.preProcessor && (stx_ptn = @.preProcessor.get(node.type , 'statement', 'expression')):
			res = stx_ptn.read(@, node);
		
		else if node.isnode:
			var write = @.new( node.type );
			for i, item -> node:
				write.read( item );
			return write;

		else if node.istoken:
			res = node;
		if res:
			if res as 'string':

				return @.patt(res, node);
			else res.isnode:
				return @.read(res, true);
			return res;


	patt (patt_str, node, write):
		var patt = getPattern(patt_str, node);
		if !patt:
			return;
		write |= @.new( patt.name || node.type );
		var patt_list = patt.list;
		for i, chip -> patt_list:
			if chip.ispattern:

				if res = parsePatternAccessor.call(@, chip, node):
					if res.type == write.type:
						for j -> res:
							write.read(res[j]);
					else:
						write.read(res);
				else if res === null && patt_list[ i-1 ] as 'string':
					Array.prototype.pop.call(write);
			else if chip:
				write.read( chip );
		return write;

	static define(map):
		for name, ptn in map:
			Reader.compilePattern(ptn);
			for n => name.split(' '):
				pattern_map[n] = ptn;

	static compilePattern(source):
		if pattern_cache[source]:
			return pattern_cache[source];
		var chips = source.replace(/ ?\| ?/g, '|').split('|'),
			patt = [];
		for i, chip -> chips:
			var ptn = {condition:'', list:[], name:'', source:chip};
			if m = chip.match(/^\(\:(\w+)\)\ ?/):
				ptn.name = m[1];
				chip = chip.substr(m[0].length);
			if m = chip.match(/^\(\?(.*?)\)\ ?/):
				ptn.condition = compilePatternCondition(m[1]);
				chip = chip.substr(m[0].length);

			while m = chip.match(/\b([A-Z]\w+[A-Z]\w+)\(#(\d+(?:\.\d+)*)?\)|#(\d+(?:\.\d+)*)?/):
				ptn.list.push(chip.slice(0, m.index));
				ptn.list.push( compilePatternAccessor(m, ptn.source) );
				chip = chip.substr( m.index + m[0].length );
			if chip:
				ptn.list.push(chip);
			patt.push(ptn);
		return pattern_cache[source] = patt;

	function compilePatternCondition(text):
		var list = [];
		while m = text.match(/^\ *#(\d+(?:\.\d+)*)? (is|eq) (.*?)(\&\&|\|\||$)/):
			list.push( {fn:m[2], indexs:m[1]&&m[1].split('.'), param:m[3].trim().split(','), logic:m[4]});
			if m[4]:
				text = text.substr(m[0].length);
				continue;
			break;
		return list;

	function compilePatternAccessor(match, source):
		var fn, index, param;
		if fn = match[1]:
			index = match[2];
		else:
			index = match[3];
		if index:
			index = index.split('.');
		return {fn: fn, indexs: index, param: param, ispattern:true, source:source};

	function getPattern(key, node):
		var patt = Reader.compilePattern(key);
		for i -> patt:
			if !patt[i].condition:
				return patt[i];
			var conds = patt[i].condition;
			
			for j, cond -> conds:
				item = getNodeItem(node, cond.indexs, true);
				if item && item[cond.fn].apply(item, cond.param):
					if cond.logic != '&&':
						return patt[i];
				else if cond.logic != '||':
					break;

	function getNodeItem(node, indexs, strict):
		var item = node;
		if indexs:
			for i => indexs:
				if item[i]:
					item = item[i];
				else:
					if strict:
						return null;
					break;
			if item == node || !item:
				return null;
		return item;

	function parsePatternAccessor(patt, node):
		var item = getNodeItem(node, patt.indexs);
		if !item:
			return null;
		var write;
		if !patt.fn:
			write = item.istoken || item.isnode ? @.read(item, node == item) : item;
		else if @[patt.fn]:
			if /^[A-Z]+$/.test(patt.fn):
				write = item.isnode || item.istoken ? @.read(item, node == item) : item;
				@[patt.fn](write);
			else:
				write = @.new(patt.name || patt.fn);
				var res = @[patt.fn](item, write);
				if res as 'string':
					@.patt(res, item, write);
		else:
			Err 'writer patt has undefined function', [patt.source, -1, patt.fn];
		return write;

Reader.define({
		'CommaExpr CommaStam ArgumentsDecl'             : 'COMMA(#)',
		'ArgumentsExpr CompelExpr ConditionStam'        : '\(COMMA(#)\)',
		'ParamsStam ParamsExpr': '\(ParamsPatt(#)\)',
		'ArrayExpr'    : '\[COMMA(#)\]',
		'JsonExpr'     : '\{COMMA(#)\}',
		'PrefixExpr PostfixExpr'                        : '#0#1',
		'ReturnStam BreakStam ContinueStam ThrowStam'   : '#0 #1',
		'DotExpr'      : '.#0',
		'DebuggerStam' : '#0',
		'FunctionDecl' : '#0 #1#2#3',
		'FunctionExpr' : '#0#1#2',
		'ExportDecl'   : '#1',
		'IfPatt'       : '#0 #1#2',
		'ElseIfPatt'   : '#0 if #1#2',
		'ElsePatt'     : '#0 #1',
		'WhileStam'    : '#0 #1#2',
		'WithStam'     : '#0 #1#2',
		'TryPatt'      : '#0 #1',
		'CatchPatt'    : '#0 #1 #2',
		'FinallyPatt'  : '#0 #1',
		'ThisExpr'     : 'this#1',
		'LabelStam'    : '#0#1 #2',
		'ForBaseConditionPatt' : '(#0; #1; #2)',
		'ForInConditionPatt' : '(#0 #1 #2)',
		'UnaryExpr'    : '(? #0 eq +) Math.abs(#1) | (? #0 is SymbolTokn) #0#1 | #0 #1',
		'NotExpr'      : '(? #1 is ValueExpr) !#0 | !(#1)',
		'TernaryExpr'  : '(? #2 is ExprStam && #4 is ExprStam) #0 #1 #2 #3 #4 | if (#0) #2; else #4',
		'LambdaExpr'   : '(? #1 is ReturnStam) function#0{#1} | function#0{return #1}',
	
		'Root'         : 'NodeStam(#0)',
		'BlockStam IndentBlockStam LineBlockStam StamBlockStam' : '{NodeStam(#)}'
});

Reader::TestPatt = function(node, __write):
	if tea.argv['--test']:
		__write.add( node );

Reader::CommDecl = function(node, __write):
	if !tea.argv['--clear'] || node.text[0] == '#':
		__write.add( node );

Reader::IdentifierExpr = function (node, __write):
	var id = node[0],
		scope = node.scope;
	if let_name = scope.getLet( id.text ):
		id.text = let_name;
	else if @.class_scope:
		switch scope.isDefined(id.text):
			case 'static', 'unknow':
				if @.class_scope.variables[id.text] == 'static':
					id.text = @.class_scope.name+'.'+id.text;
	__write.read( id );

Reader::ComputeExpr = function (node, __write):
	var list = [];
	for i -> node:
		switch node[i].istoken && node[i].text:
			case '**':
				list.push( 'Math.pow(', list.pop(), ', ', node[++i], ')' );
			case '\\':
				list.push( 'Math.floor(', list.pop(), '/', node[++i], ')' );
			default:
				list.push( node[i] );
	__write.read(list);

Reader::CompareExpr = function (node, __write):
	var list = [];
	if node.length == 5 && node[3].eq('<', '>', '>=', '<='):
		return '#0 #1 #2 && #2 #3 #4';

	for i -> node:
		switch i%2 && node[i].text:
			case 'as':
				if node[i+1].type == 'StringTokn':
					list.push( 'typeof ', list.pop(), ' == ', node[++i] );
				else:
					list.push( ' instanceof ', node[++i] );
			case 'in':
				if node[i+1].type == 'ArrayExpr':
					list.push( node[++i], '.indexOf(', list.pop(), ')>=0');
				else:
					list.push( node[++i], '.hasOwnProperty(', list.pop(), ')');
			case 'of':
				list.push( '[].indexOf.call(', node[++i], ', ', list.pop(), ')>=0');
			case 'is':
				node[i].text = ' === ';
				list.push(node[i]);
			case 'not is':
				node[i].text = ' !== ';
				list.push(node[i]);
			default:
				if i%2:
					node[i].text = ' '+node[i].text+' ';
				list.push( node[i] );
	__write.read( list );

Reader::LogicExpr = function (node, __write):
	for i=1; i < node.length; i+=2:
		switch node[i].text:
			case 'and':
				node[i].text = '&&';
			case 'or':
				node[i].text = '||';
	if node.length == 3:
		if node[2].is('ExprStam'):
			return '#0 #1 #2';
		if node.parent.is('NodeStam'):
			if node[1].text == '||':
				if node[0].is('ValueExpr'):
					return 'if (!#0) #2';
				return 'if (!(#0)) #2';
			return 'if (#0) #2';
		return '#0 #1 (#2)';
	__write.read( @.JOIN(Hash.slice(node), ' ') );

Reader::['Ternary2.5Expr'] = function(node, __write):
	if node.parent.is('NodeStam'):
		return 'if (#0) #2';
	else:
		if !node[0].is('ValueExpr'):
			var ref = AllocateRefName(node.scope);
			return '(('+ref+' = #0) != null ? '+ref+' : #2)';
	return '(#0 != null ? #0 : #2)';

Reader::SeleteStam = function (node, __write):
	switch node[1].text:
		case 'if', '<-':
			return 'if (#2) #0';
		case 'or', '||':
			if node[0].is('ValueExpr'):
				return 'if (!#0) #2';
			return 'if (!(#0)) #2';
		default:
			return 'if (#0) #2';

Reader::AssignmentExpr = function(node, __write):
	var left = node[0], right = node[2];
	if left.type == 'ArrayPatt':
		return AssignmentArrayPatt.call(@, __write, left, right, node);

	else if left.type == 'AccessorPatt' && left[-1].type == 'SlicePatt':
		return AssignmentSlicePatt.call(@, __write, left, right, node)

	else if node.parent.type == 'ArgumentsExpr':
		return left;
	else:
		switch node[1].text:
			case '?=':
				if node.parent && node.parent.is('NodeStam'):
					return 'if (#0 == null) #0 = #2';
				return '(#0 == null && (#0 = #2))'
			case '|=':
				if node.parent && node.parent.is('NodeStam'):
					return 'if (!#0) #0 = #2';
				return '(!#0 && (#0 = #2))'
	if node.parent.type == 'JsonExpr':
		if node[0].is('IdentifierTokn')
			return '"#0"#1 #2';
	return '#0 #1 #2';

Reader::AssignmentDecl = Reader::AssignmentExpr;

Reader::ParamsPatt = function(node, __write):
	for i, item -> node:
		if item.istoken && item.text == ',':
			__write.add('null');
		else:
			__write.read( item );
	@.COMMA( __write );

Reader::SlicePatt = function(node, __write):
	var ab = AccessorSlicePatt.call(@, node);
	if !ab[1]:
		__write.read( '.slice(', ab[0]||'', ')' );
	else:
		__write.read( '.slice(', ab[0]||'0', ', ', ab[1], ')' );

Reader::MemberExpr = function(node, __write):
	if node[0].type == 'UnaryExpr' && node[0][0].text == '-':
		var parent = node.parent.clone();
		parent.length = node.index;
		if parent:
			__write.read( '[#0.length#1]', [parent, node[0]] );
	else:
		__write.read('[', node[0], ']');

Reader::MemberPatt = function(node, __write):
	switch node[0].text:
		case '::':
			node[0].text = '.prototype';
		case '..':
			node[0].text = '.constructor';
	return '#0.#1';

Reader::LetDecl = function(node, __write):
	node[0].text = 'var';
	ResetDefineVariableDecl(node[1], node.scope, 'let', 'let_');
	return '#0 #1';

Reader::VarDecl = function(node, __write):
	ResetDefineVariableDecl(node[1], node.scope, 'defined');
	return '#0 #1';

Reader::DoWhileStam = function(node, __write):
	if node[2]:
		return '#0 #1 #2 #3';
	else:
		return '#0{NodeStam(#1)break;} while (true)';

Reader::TryStam = function(node, __write):
	if node.length > 1:
		return '#';
	else:
		return '# catch (_e){}';

Reader::SwitchStam = function(node, __write):
	var block = node[2],
		block_body = @.new('NodeStam'),
		exp_cache = [], case_write, sub_block;

	for item => block:
		case_write |= @.new(item.type);
		if item.type == 'CaseStam':
			for key => item[1]:
				case_write.read( item[0], ' ', key, ':' );
			sub_block = item[3];
		else:
			case_write.read( item[0], ':' );
			sub_block = item[2];

		if sub_block:
			var sub_write = @.SwitchCaseBlock( sub_block, @.new('NodeStam') );
			block_body.read( case_write.read(sub_write) );
			case_write = null, sub_block = null;

	__write.read( node[0],' ', node[1], @.new(block.type, '{', block_body, '}') );

Reader::SwitchCaseBlock = function (node, __write):
	var last = node.length - 1;
	while node[last] && node[last].is('CommDecl'):
		last -= 1;
	
	var insert_break = true;
	if node[last] && node[last].is('ReturnStam', 'BreakStam', 'ContinueStam'):
		if node[last].type == 'ContinueStam':
			node[last] = null;
		insert_break = false;

	@.NodeStam( node, __write );
	if insert_break:
		__write.read( '\nbreak;' );
	return __write;

Reader::forCondition = function(node, __write):
	var scope = node.scope;
	var exp1 = node[0], exp2 = node[1], exp3 = node[2];
	var $mark = exp2 && exp2.text || '->', $var, $i, $i_text, $def, $temp, $len, $tar, $tar_exp;

	if exp1.type == 'VarDecl':
		$var = true, exp1 = exp1[1];
		
	if !exp3:
		exp3 = exp1, exp1 = null;

	if exp1:
		switch exp1.type:
			case 'CommaExpr', 'ArgumentsDecl':
				$i = exp1[0], $temp = exp1[1];
			default:
				$i = exp1;
	if $i:
		if $i.type == 'AssignmentDecl' || $i.type == 'AssignmentExpr':
			$def = $i[2], $i = $i[0];
		else if $i.type == 'ConstTokn':
			$def = $i, $i = null
		if $i:
			if $i.type == 'IdentifierExpr':
				$i = $i[0];
			if $i.type != 'IdentifierTokn':
				tea.throw 'for condition(3) statiment syntax error!', $i;
			if /\=|of/.test($mark):
				$temp = $i, $i = null;
	if !$i:
		$var = true, $i = AllocateVarName(scope);
	
	$i_text = $i.text || $i;

	var def_type = scope.isDefined($i_text);
	$var = $var || !def_type || def_type == 'let';

	if exp3.type =='CommaExpr' && exp3.length == 1:
		exp3 = exp3[0]

	switch exp3.is('ArrayExpr', 'JsonExpr', 'AccessorExpr', 'IdentifierExpr', 'AtExpr', 'NumTokn'):
		case 'AccessorExpr', 'IdentifierExpr', 'AtExpr':
			$tar = exp3;
		case 'NumTokn':
			$len = @.new('NumTokn').read(exp3);
		default:
			$tar = $i_text+'_ref';
			$tar_exp = @.new('AssignmentExpr').read( $tar, ' = ', exp3);

	$len = $len || @.new('AssignmentExpr').read($tar, '.length');
	$tar = @.new('IdentifierExpr').read($tar);
	$i = @.new('IdentifierExpr').read($i);
	return [$mark, $var, $i, $def, $temp, $len, $tar, $tar_exp];

Reader::ForStam = function(node, __write):
	var condition = node[1];
	if condition.type == 'ForBaseConditionPatt':
		// condition.type == 'ForInConditionPatt':
		return '#0 #1#2';

	var scope = node.scope;
	var [$mark, $var, $i, $def, $temp, $len, $tar, $tar_exp] = @.forCondition(condition);

	scope.setLet('__length', $len.text );
	scope.setLet('__index',  $i.text );
	scope.setLet('__target', $tar.text );

	var cond_body  = @.new('ConditionBody');
		block_body = @.new('NodeStam');

	if /in|of/.test($mark):
		cond_body.read( $var ? 'var ':'', $i, ' in ', $tar );
		if $tar_exp:
			__write.read( @.VAR( $tar_exp ), ';\n' );
		block_body.add( @.new('IfStam', 'if (!#0.hasOwnProperty(#1)) continue;\n', [$tar, $i]) );
		if $temp:
			block_body.add( @.new('AssignmentExpr', 'var #0 = #1[#2];\n', [$temp, $tar, $i]) );
	else:
		if $mark[0] == '<':
			if $def = $def || [$tar, '.length-1']:
				$def = [$i, '=', $def];
			cond_body.read('#0; #1 >= #2; #1--', [@.VAR($tar_exp, $def, $temp), $i, '0'] );
		else:
			if $def = $def || $var && '0':
				$def = [$i, '=', $def];
			cond_body.read('#0; #1 < #2; #1++', [@.VAR($tar_exp, $def, $temp), $i, $len] );

		if $temp:
			block_body.add( @.new('AssignmentExpr', '#0 = #1[#2];\n', [$temp, $tar, $i]) );
	
	@.NodeStam(node[2], block_body);
	__write.add(node[0], ' ', @.new('ForConditionPatt', '(', cond_body, ')'), @.new(node[2].type, '{', block_body, '}'));

Reader::PackageExpr = function(node, __write):
	if node.length == 2:
		return '(function()#1)()';

	var params = @.new('ParamsExpr'),
		argus = @.new('ArgumentsExpr'),
		has_ass = false;
	if node[1].length:
		ResetDefineVariableDecl(node[1], node.scope, 'argument');
		for i, item -> node[1]:
			if item.type == 'AssignmentDecl':
				has_ass = true;
				argus.read( item[0] );
				params.read( item[2] );
			else:
				argus.read( '_'+i );
				params.read( item );

	__write.read( '(function(#0)#1)(#2)', [@.COMMA(argus), node[2], @.COMMA(params)]);

/*******************************************/
Reader::ClassExpr = function(node, __write):
	var _i = 1, scope = node.scope, name, extend, block, is_ass = false;
	if node[_i].type == 'IdentifierTokn':
		name = node[_i++];
	if node[_i].type == 'ExtendsExpr':
		extend = node[_i++];
	if !name:
		if node.parent.type == 'AssignmentDecl':
			is_ass = true;
			name = node.parent[0];
		else if node.parent.type == 'AssignmentExpr':
			is_ass = true;
			name = node.parent[0][0];
	if !name:
		Err 321, node[0];

	scope.name = name.text;
	block = node[_i];

	var old_scope = @.class_scope;

	@.class_scope = scope;

	var block_write = @.new('NodeStam');
	@.NodeStam(block, block_write);

	if extend:
		block_write.insert(0, @.ExtendsExpr(extend));

	var construct_write = @.new('ConstructorStam'),
		construct_body = @.new('NodeStam');
	if scope.inits.length:
		construct_body.read(scope.inits);
	if scope.construct:
		@.NodeStam(scope.construct[2], construct_body);
		construct_write.read('function #0#1{#2}\n', [name, scope.construct[1], construct_body]);
	else:
		construct_write.read('function #0(){#1}\n', [name, construct_body]);

	block_write.insert(0, construct_write);

	block_write.read('\nreturn #0;', [name]);
	if is_ass:
		__write.read('(function(){#0})()', [block_write]);
	else:
		__write.read('var #1 = (function(){#0})()', [block_write, name]);

	@.class_scope = old_scope;

Reader::ExtendsExpr = function(node, __write):
	__write |= @.new('ExtendsExpr');
	var scope = node.scope,
		name  = scope.name,
		list  = node[1];

	__write.read('
		#0.prototype = new #1();
		#0.prototype.constructor = #0;
		#0.prototype.__super__ = #1.prototype;\n
		', [name, list[0]] );
	if list.length > 1:
		__write.read('
			#0.__extends = function(){
				for (var i=0; i<arguments.length; i++){
					var _super = arguments[i].prototype;
					for (var name in _super)
						if (_super[name].hasOwnProperty(name))
							this.prototype[name] = _super[name];
				}
			};
			#0.__extends(COMMA(#1));\n
			', [name, Hash.slice(list, 1)]);
	return __write;

Reader::SuperExpr = function(node, __write):
	var acc = node[0], pam = node[1], supe = acc[0];
	supe.text = 'this.__super__';
	if acc.length == 1:
		supe.text += '.'+(node.scope.name||'constructor');
	if pam:
		var pam_write = @.read(pam);
		pam_write[1].insert(0, 'this', ', ');
		__write.read(acc, '.call', pam_write);
	else:
		return '#0.call(this, arguments)';

Reader::AtExpr = function(node, __write):
	var scope = node.scope;
	if scope.type == 'ClassExpr':
		node[0].text = scope.name;
	else:
		scope = scope.queryParent('ClassExpr');
		if scope && ClassStaticAtSymbol(scope, node):
			node[0].text = scope.name;
		else:
			node[0].text = 'this';
	return '#';

Reader::SetterDecl = function(node, __write):
	if node.parent.type == 'JsonExpr':
		return '#0 #1#2#3';
	var class_scope = node.scope.parent;
	if class_scope.type == 'ClassExpr':
		var type = node.type=='SetterDecl' ? '__defineSetter__' : '__defineGetter__';
		if node.length < 4:
			__write.read('#0.prototype.'+type+'("#1", function()#2)', [class_scope.name, node[1], node[2]]);
		else:
			__write.read('#0.prototype.'+type+'("#1", function#2#3)', [class_scope.name, node[1], node[2], node[3]]);

Reader::GetterDecl = Reader::SetterDecl;

Reader::MethodDecl = function(node, __write):
	if node.parent.type == 'JsonExpr':
		return '"#0": function#1#2';
	var scope = node.scope,
		class_scope = scope.parent;
	switch class_scope.type:
		case 'ClassExpr':
			var class_name = class_scope.name;
			if scope.name == 'constructor':
				class_scope.construct = node;
				return '';
			else:
				__write.read('#0.prototype.#1 = function #2#3', [class_name, node[0], node[1], node[2]]);
		default:
			return 'function #0#1#2';

Reader::StaticDecl = function(node, __write):
	var class_scope = node.scope;
	if class_scope.type != 'ClassExpr':
		class_scope = class_scope.parent;
	var exp = node[1];
	if exp.type == 'ArgumentsDecl':
		for i, item -> exp:
			if item.type == 'AssignmentDecl': 
				__write.read('#0.#1 #2 #3;', [class_scope.name, item[0], item[1], item[2]]);
			else:
				__write.read('#0.#1 = null;', [class_scope.name, item]);
			if i < exp.length - 1:
				__write.add('\n');
	else:
		__write.read('#0.#1 = function#2#3;', [class_scope.name, exp[0], exp[1], exp[2]]);

Reader::ProtoDecl = function(node, __write):
	var class_scope = node.scope.queryParent('ClassExpr');
	if !class_scope:
		Err 325, node[0];
	var exp = node[1],
		class_name = class_scope.name;
	if exp.type == 'ArgumentsDecl':
		for i, item -> exp:
			if item.type == 'AssignmentDecl': 
				__write.read('#0.prototype.#1 #2 #3;', [class_name, item[0], item[1], item[2]]);
			else:
				__write.read('#0.prototype.#1 = null;', [class_name, item]);
			if i < exp.length - 1:
				__write.add('\n');
	else:
		__write.read('#0.prototype.#1 = function#2#3;', [class_name, exp[0], exp[1], exp[2]]);

Reader::InitDecl = function(node, __write):
	var class_scope = node.scope;
	if class_scope.type != 'ClassExpr':
		Err 326, node[0];
	var exp = node[1],
		write = @.new('InitDecl');
	if exp.type == 'ArgumentsDecl':
		for i, item -> exp:
			if item.type == 'AssignmentDecl': 
				write.read('this.#0 #1 #2;\n', item);
			else:
				write.read('this.# = null;\n', item);
	else:
		write.read('this.#0 = function#1#2;\n', exp);
	class_scope.inits.push(write);
	return '';

/*******************************************/

Reader::RequireStam = function(node, __write):
	var argv = tea.argv || {},
		root_scope = argv['--join'] ? node.scope.root : null,
		params = ParseRequireFile(node[1], root_scope);

	if params.length > 1:
		if node.parent.is('AssignmentDecl', 'AssignmentExpr'):
			if node.parent[0].type == 'ArrayExpr':
				format = '#0(#1)';
				type = 'arr';
				write = @.new('ArrayExpr');
			else:
				format = '"#2": #0(#1)';
				type = 'json';
				write = @.new('JsonExpr');
		else:
			format = 'var #2 = #0(#1)';
			type = 'var';
			write = @.new('VarExpr');
	else:
		write = __write;
		format = '#0(#1)';

	for i -> params:
		_format = params[i].name ? format : '#0(#1)';
		if params[i].file && root_scope:
			write.read( @.new('RequireExpr', _format, ['__require', '"'+root_scope.joinRequire(params[i].file)+'"', params[i].name]) );
		else:
			write.read( @.new('RequireExpr', _format, [node[0], params[i].expr, params[i].name]) );
	
	switch type:
		case 'var':
			__write.read( @.JOIN(write, ';\n') );
		case 'json':
			__write.read( '{', @.JOIN(write, ', '), '}' );
		case 'arr':
			__write.read( '[', @.JOIN(write, ', '), ']' );

Reader::NodeStam = function (node, __write):
	__write |= @.new('NodeStam');
	var len = node.length - 1;
	for i, item -> node:
		res = @.read(item);
		if res && (res.istoken || res.length):
			__write.add( res );
			if item.type != 'CommDecl' && (item.is('AssignmentExpr','ClausesStam', 'CommaStam') || ! /(\}|;)$/.test(res.lastText) ):
				__write.add(';');
			if i < len:
				__write.add('\n');

	NodeStamUnDefined.call(@, node, __write);
	return __write;

Reader::COMMA = function (write):
	return @.JOIN(write, ',');

Reader::JOIN = function (write, separator):
	separator ?= ' ';
	for var i = write.length-1; i >=1; i--:
		Array.prototype.splice.call(write, i, 0, separator);
	return write;

Reader::VAR = function ():

	var list = [];
	for i -> arguments:
		if arguments[i]:
			list.push( @.read(arguments[i]) );

	if list.length:
		@.COMMA(list);
		var write = @.new('VarDecl', 'var #0', [list]);
		return write;

function NodeStamUnDefined(node, __write):
	var argv = tea.argv || {};
	var scope = node.scope;
	var a = 0;
	while __write[a] && (__write[a].type == 'CommDecl' || __write[a] == '\n'):
		a += 1;

	if !argv['--safe']:
		var un_defineds = scope.get('undefined');
		if un_defineds && un_defineds.length:
			__write.insert(a, @.VAR.apply(@, un_defineds), ';\n');

	var argus = scope.argumentsDefine;
	if argus && argus.length:
		var write = @.new('ArgumentsStam');
		for i -> argus:
			write.read( 'if (#0 == null) #0 #1 #2;\n', argus[i] );
		__write.insert(0, write);

	var exts = scope.exports;
	if exts && exts.length:
		var write = @.new('ExportStam');
		for i -> exts:
			write.add('\nmodule.exports.'+exts[i]+' = '+exts[i]+';');
		__write.add(write);

	// if !node.parent.is('ScopeNode'):
	// 	var lets = scope.get('let');
	// 	if lets && lets.length:		
	// 		for i in lets:
	// 			lets[i] = scope.lets[lets[i]] || lets[i];
	// 		var write = @.new('DeleteLetStam').read(lets, 'undefined');
	// 		__write.read('\n', @.JOIN(write, ' = '), ';');

function AssignmentSlicePatt(__write, left, right, node):
	left.length -= 1;
	if left[left.length].length == 0:
		__write.read( '#0.push(#1)', [left, right] );
	else:
		var ab = AccessorSlicePatt.call(@, left[left.length], true );
		__write.read( '#0.splice.apply(#0, [#1, #2].concat(#3))', [left, ab[0], ab[1], right] );
	
function AssignmentArrayPatt(__write, left, right, node):
	if right.type == 'ArrayExpr':
		for i -> left:
			if i > 0:
				__write.add(', ')
			if right[i]:
				__write.read( '#0 #1 #2', [left[i], node[1], right[i]] );
			else:
				Err 'array pattern assignment declaration syntax error', right[ i-1 ];
	else:
		var ref = AllocateRefName( node.scope );
		if node.parent.parent.type == 'VarDecl':
			node.scope.set('defined', ref, true);
		__write.read( '#0 = #1', [ref, right] );
		for i -> left:
			__write.read( ', #0 #1 #2[#3]', [left[i], node[1], ref, i+''] );

function AccessorSlicePatt(node, count_b):
	var a, b 
	if node.length == 3:
		a = node[0], b = node[2];
	else if node.length == 2:
		if node[0].text == ':':
			a = 0, b = node[1];
		else:
			a = node[0], b = 0;
	else if node.length >= 1:
		a = 0, b = 0;

	if count_b:
		var parent = node.parent;
		var write = @.new('AccessorExpr');
		if b:
			write.type = 'ComputeExpr';
			if b[0] && b[0].text == '-':
				write.read( parent, '.length', b);
			else:
				write.read( b, '-', a);
			b = write;
		else:
			b = write.read(parent, '.length');
	return [a, b];

function ResetDefineVariableDecl(decl_list, scope, type, prefix):
	for i, left -> decl_list:
		if left.type == 'AssignmentDecl':
			left = left[0];
		if left.type == 'ArrayPatt':
			for item => left:
				item.text = ResetDefine(scope, type, item.text, prefix);
		else if left.istoken:
			left.text = ResetDefine(scope, type, left.text, prefix);
		else:
			decl_list[i] = ResetDefine(scope, type, decl_list[i], prefix);

function ResetDefine(scope, type, name, prefix):
	scope.set(type, name, true);
	if prefix:
		if type == 'let':
			scope.lets[name] = prefix+name;
		return prefix+name;
	return name;

function AllocateVarName(scope):
	var keymap = 'ijklmnopqrstuvwxyz';
	for i -> keymap:
		if !scope.isDefined('_'+keymap[i]):
			var key = '_'+keymap[i];
			scope.set('let', key);
			return key;
	return '__i';

function AllocateRefName(scope):
	var i = 0, name = '_ref', stat = scope.isDefined(name, null, 1);
	while true:
		if !stat || stat == 'let':
			scope.set('undefined', name);
			return name;
		name += i++;
		stat = scope.isDefined(name, null, 1);

function ClassStaticAtSymbol(clas_scope, node):
	if clas_scope.type = 'ClassExpr':
		if node.length > 1 && node[1].type == 'DotExpr':
			var member = node[1][0];
			if member.type == 'IdentifierTokn' && clas_scope.statics.indexOf(member.text) != -1:
				var name = member.text;
				if clas_scope.protos.indexOf(name) == -1:
					return name;
	return false;

function ParseRequireFile(node, join):
	var list    = [],
		tar_dir  = node.root.filePath || '';
	// console.log(node.root.fileName, tea.countOutput(node.root.fileName));
	for i, item -> node:
		if item.is('StringTokn'):
			if join && Path.isPathText(item.text):
				var files = Path.parseFile(item.text, tar_dir, ['.js', '.tea']);
				if !files.error:
					if files.length == 1:
						list.push( {name:RequireModuleName(file), expr: item, file:files[0]} );
						continue;
					for file => files:
						list.push( {name:RequireModuleName(file), expr: item.clone('"'+file+'"'), file:file} );
					continue;
				tea_log '** [Require: Can not join file: '+item.text+']';

			list.push( {name:RequireModuleName(item.text), expr: item, file:''} );
		else:
			list.push( {name:'', expr: item, file:''} );
	return list;

function RequireModuleName(file):
	// if Path.isFile(file):
	// 	var text = Text.readFile(file),
	// 		m = text.match(/exports\s*=(\s*[\w\$][\w\$\d]*)/g);
	// 	if m:
	// 		return m[1];
	return Text.getName(file);

module.exports = Reader;
